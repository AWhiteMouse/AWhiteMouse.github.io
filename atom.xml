<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://awhitemouse.github.io/</id>
    <title>白山</title>
    <updated>2021-06-11T08:05:57.969Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://awhitemouse.github.io/"/>
    <link rel="self" href="https://awhitemouse.github.io/atom.xml"/>
    <subtitle>温故而知新。</subtitle>
    <logo>https://awhitemouse.github.io/images/avatar.png</logo>
    <icon>https://awhitemouse.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 白山</rights>
    <entry>
        <title type="html"><![CDATA[Antd Form表单设置validateFields校验无飘红提示]]></title>
        <id>https://awhitemouse.github.io/post/antd-form-biao-dan-she-zhi-validatefields-xiao-yan-wu-piao-hong-ti-shi/</id>
        <link href="https://awhitemouse.github.io/post/antd-form-biao-dan-she-zhi-validatefields-xiao-yan-wu-piao-hong-ti-shi/">
        </link>
        <updated>2021-06-10T02:48:06.000Z</updated>
        <summary type="html"><![CDATA[<p>使用 <code>validateFields</code>，点击保存的时候控制台会打印警告，但是表单中无飘红提示。</p>
]]></summary>
        <content type="html"><![CDATA[<p>使用 <code>validateFields</code>，点击保存的时候控制台会打印警告，但是表单中无飘红提示。</p>
<!-- more -->
<h2 id="问题背景">问题背景</h2>
<p>写了一个表单校验，用来验证输入的字符串是否全为空格。当我点击保存的时候（调用 <code>validateFields</code> 方法），在控制台提示了如下警告：</p>
<figure data-type="image" tabindex="1"><img src="https://awhitemouse.github.io//post-images/1623294251997.png" alt="" loading="lazy"></figure>
<p>代码是这样的：</p>
<pre><code class="language-jsx">&lt;FormItem
    label=&quot;规格&quot;
    className=&quot;contact-detail-info-form-item&quot;
    {...formItemLayout}
&gt;
    {
        getFieldDecorator('specification', {
            initialValue: data.specification,
            rules: [
                {
                    required: true,
                    message: '请输入规格',
                },
                {
                    validator: (rule, value, callback) =&gt; {
                        /* 注意看这里！！！ */
                        if (value.length &amp;&amp; !value.trim().length) {
                            callback('规格文案不能全为空格');
                        }
                        else {
                            callback();
                        }
                    }
                }
            ],
        })(&lt;Input
            allowClear
            className=&quot;custom-input&quot;
            placeholder=&quot;请输入规格&quot;
        /&gt;)
    }
&lt;/FormItem&gt;
</code></pre>
<h2 id="解决方案">解决方案</h2>
<p>通过查阅相关问题发现，只要在 <code>validator</code> 方法的判断中加上对于 <code>value</code> 值本身的判断就能解决问题。像下面这样：</p>
<pre><code class="language-jsx">&lt;FormItem
    label=&quot;规格&quot;
    className=&quot;contact-detail-info-form-item&quot;
    {...formItemLayout}
&gt;
    {
        getFieldDecorator('specification', {
            initialValue: data.specification,
            rules: [
                {
                    required: true,
                    message: '请输入规格',
                },
                {
                    validator: (rule, value, callback) =&gt; {
                        /* 注意看这里！！！加上了 value 的判断 */
                        if (value &amp;&amp; !value.trim().length) {
                            callback('规格文案不能全为空格');
                        }
                        else {
                            callback();
                        }
                    }
                }
            ],
        })(&lt;Input
            allowClear
            className=&quot;custom-input&quot;
            placeholder=&quot;请输入规格&quot;
        /&gt;)
    }
&lt;/FormItem&gt;
</code></pre>
<p>加上对于 value 的判断后再去校验就出现飘红提示了。</p>
<figure data-type="image" tabindex="2"><img src="https://awhitemouse.github.io//post-images/1623294311718.png" alt="" loading="lazy"></figure>
<h2 id="问题原因分析">问题原因分析</h2>
<p>虽然问题解决了，但是如此怪异的问题我还是得弄清楚原因才行，不然再次遇到同类问题的时候可能不知道该怎么处理。</p>
<p>对比了一下前后的区别，发现将 <code>value.length</code> 改成 <code>value</code> 的区别在于 <code>value.length</code> 这个表达式本身就可能报错。比如当 <code>value</code> 为 <code>undefined</code> 时。</p>
<p>而 <code>validator</code> 非常强调的一件事就是 <code>callback</code> 方法必须要被执行。而当 <code>value</code> 为 <code>undefined</code> 时，程序在运行时就会报错，导致 <code>callback</code> 方法没有被调用。</p>
<p>而程序报错没有却没有在控制台看到错误打印的原因是可能是因为 Antd Form validator 外部使用了 <code>try...catch</code> 对错误进行捕获。</p>
<h3 id="实践出真知">实践出真知。</h3>
<p>为了验证这个猜想的正确性，我在代码代码中添加了如下的打印：</p>
<pre><code class="language-js">// 校验空格
const validateBlank = (rule: any, value: string, callback: (str?: string) =&gt; void) =&gt; {
    console.log(1);
    if (value.length &amp;&amp; !value.trim().length) {
        console.log(2);
        callback('规格文案不能全为空格');
    }
    else {
        console.log(3);
        callback();
    }
};
</code></pre>
<p>然后点击保存。发现在控制台中仅仅打印了 <code>1</code>。这样的验证结果是符合我的猜想的。为了更加坚定这个结论，我查阅了 Antd 文档。</p>
<h3 id="知子莫如父">知子莫如父。</h3>
<p>我在 Antd 文档中发现了这样一个FAQ：<a href="https://ant.design/components/form-cn/#%E8%87%AA%E5%AE%9A%E4%B9%89-validator-%E6%B2%A1%E6%9C%89%E6%95%88%E6%9E%9C">自定义 validator 没有效果</a>.</p>
<p>描述如下：</p>
<blockquote>
<p>这是由于你的 <code>validator</code> 有错误导致 <code>callback</code> 没有执行到。你可以选择通过 <code>async</code> 返回一个 promise 或者使用 <code>try...catch</code> 进行错误捕获：</p>
</blockquote>
<p>这段描述的第一句话就正中下怀啊。官方提供的解决方案是在 <code>validator</code> 方法内部使用 <code>try...catch</code> 进行错误捕获，然后在 <code>catch</code> 语句中调用一下 <code>callback</code>。详情参见上方的文档。</p>
<h2 id="参考链接">参考链接</h2>
<ol>
<li><a href="https://blog.csdn.net/weixin_30698775/article/details/112592844">控制台输入框_antdvue:form表单提交时,只在控制台输出error,输入框不标红 底下也没提示...</a>.</li>
</ol>
<h2 id="拓展">拓展</h2>
<ol>
<li><a href="https://juejin.cn/post/6844903935728189447">antd-Form表单设置validateFields校验无飘红提示</a>.</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何处理按钮组边框线的问题]]></title>
        <id>https://awhitemouse.github.io/post/ru-he-chu-li-an-niu-zu-bian-kuang-xian-de-wen-ti/</id>
        <link href="https://awhitemouse.github.io/post/ru-he-chu-li-an-niu-zu-bian-kuang-xian-de-wen-ti/">
        </link>
        <updated>2021-06-09T07:31:39.000Z</updated>
        <summary type="html"><![CDATA[<p>关键点在于如何处理相邻元素的边框线。</p>
]]></summary>
        <content type="html"><![CDATA[<p>关键点在于如何处理相邻元素的边框线。</p>
<!-- more -->
<h2 id="基本用法">基本用法</h2>
<p>最常见的用法是使用css的 <code>元素选择器</code>，代码示例如下：</p>
<p class="codepen" data-height="265" data-theme-id="dark" data-default-tab="html,result" data-user="awhitemouse" data-slug-hash="yLMqEeG" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="元素选择器消除相邻元素边框线">
  <span>See the Pen <a href="https://codepen.io/awhitemouse/pen/yLMqEeG">
  元素选择器消除相邻元素边框线</a> by chenxin (<a href="https://codepen.io/awhitemouse">@awhitemouse</a>)
  on <a href="https://codepen.io">CodePen</a>.</span>
</p>
<p>这种方法对付一般性的需求是没有问题的，但是如果遇到了比较特殊的情况就出问题了，比如这样：</p>
<figure data-type="image" tabindex="1"><img src="https://awhitemouse.github.io//post-images/1623224766667.png" alt="" loading="lazy"></figure>
<p>因为换行的原因导致中间元素没有右边框的问题被暴露出来了。</p>
<h2 id="margin-right负值">margin-right负值</h2>
<p>为了解决换行导致的样式问题，需要保证每个元素的左右边框都存在。</p>
<p>那么问题转换成了如何将两个元素的相邻边框压缩成1个边框。</p>
<p>☝️一个很好的办法就是使用 margin-right 负值。代码示例如下：</p>
<p class="codepen" data-height="265" data-theme-id="dark" data-default-tab="html,result" data-user="awhitemouse" data-slug-hash="LYWBrpG" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="margin-right负值解决相邻边框线的问题">
  <span>See the Pen <a href="https://codepen.io/awhitemouse/pen/LYWBrpG">
  margin-right负值解决相邻边框线的问题</a> by chenxin (<a href="https://codepen.io/awhitemouse">@awhitemouse</a>)
  on <a href="https://codepen.io">CodePen</a>.</span>
</p>
<script async src="https://cpwebassets.codepen.io/assets/embed/ei.js"></script>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【转载】探秘 flex 上下文中神奇的自动 margin]]></title>
        <id>https://awhitemouse.github.io/post/zhuan-zai-tan-mi-flex-shang-xia-wen-zhong-shen-qi-de-zi-dong-margin/</id>
        <link href="https://awhitemouse.github.io/post/zhuan-zai-tan-mi-flex-shang-xia-wen-zhong-shen-qi-de-zi-dong-margin/">
        </link>
        <updated>2021-05-31T06:19:24.000Z</updated>
        <summary type="html"><![CDATA[<p><a href="https://www.cnblogs.com/coco1s/p/10910588.html">阅读原文</a></p>
]]></summary>
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/coco1s/p/10910588.html">阅读原文</a></p>
<!-- more -->
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JS复制canvas图片到剪切板]]></title>
        <id>https://awhitemouse.github.io/post/js-fu-zhi-tu-pian-dao-jian-qie-ban/</id>
        <link href="https://awhitemouse.github.io/post/js-fu-zhi-tu-pian-dao-jian-qie-ban/">
        </link>
        <updated>2021-04-27T04:10:55.000Z</updated>
        <summary type="html"><![CDATA[<p>最近在写一个小工具，用来生成指定宽高与颜色的图片：<a href="https://hbuecx.com/GImage/">传送门</a>.我想给它添加可以一键复制图片到剪切板的功能，所以才有了这篇文章。</p>
]]></summary>
        <content type="html"><![CDATA[<p>最近在写一个小工具，用来生成指定宽高与颜色的图片：<a href="https://hbuecx.com/GImage/">传送门</a>.我想给它添加可以一键复制图片到剪切板的功能，所以才有了这篇文章。</p>
<!-- more -->
<p>作为一名前(面)端(向)高(谷)级(歌)开发人员，基本素养还是要具备的。前车之鉴，后事之师。不仅要汲取前人的经验，还需要注意避开前人踩过的坑。</p>
<p>实现类似功能的第三库包有很多，但是我只是做了一个小工具，就一个html文件而已。如果为了这么一个功能去引用一个第三方包就有点多余。所以还是决定自己写简单的函数。</p>
<p>目前相关的文章讲解关于 <code>JS复制图片到剪切板</code> 的技术方案有两种：</p>
<ul>
<li><code>document.execCommand('copy')</code></li>
<li><code>navigator.clipboard.write()</code></li>
</ul>
<p>但是 <code>document.execCommand('copy')</code> 再部分场景下会失效，秉持着高(偷)效(懒)得原则，果断选择了 <code>navigator.clipboard.write()</code> 的方案来实现图片复制。</p>
<h2 id="源码">源码</h2>
<pre><code class="language-js">// 复制图片到剪切板
function clipboard() {
    navigator.permissions.query({ name: 'clipboard-write' }).then(result =&gt; {
        if (result.state === 'granted') {
            var imageType = getImageType();
            canvas.toBlob(function deal(blob) {
                var clipboardItem = new ClipboardItem({[`image/${suffix}`]: blob});
                navigator.clipboard.write([clipboardItem]).then(() =&gt; {
                    alert('复制成功');
                });
            }, imageType);
        }
    });
}
</code></pre>
<h2 id="参考">参考</h2>
<ol>
<li><a href="https://www.jianshu.com/p/eab9bab4d5b5">记js复制图片到剪贴板的坑</a>.</li>
<li><a href="https://www.canvasapi.cn/HTMLCanvasElement/toBlob">canvas API中文网 - 中文文档 - HTMLCanvasElement.toBlob()</a>.</li>
<li><a href="https://stackoverflow.com/questions/63561767/typeerror-failed-to-construct-clipboarditem-failed-to-convert-value-to-blob?newreg=6aa69267fb374f27aade256acaa0cfaf">javascript - TypeError: Failed to construct 'ClipboardItem': Failed to convert value to 'Blob' - Stack Overflow</a>.</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[还在用 npm install ? 试试 npm ci 吧！]]></title>
        <id>https://awhitemouse.github.io/post/ni-zhi-dao-npm-ci-ma/</id>
        <link href="https://awhitemouse.github.io/post/ni-zhi-dao-npm-ci-ma/">
        </link>
        <updated>2021-04-22T03:19:57.000Z</updated>
        <summary type="html"><![CDATA[<p>在有 <code>package-lock</code> 的项目，我们可以使用 <code>npm ci</code> 来替代 <code>npm install</code>.</p>
]]></summary>
        <content type="html"><![CDATA[<p>在有 <code>package-lock</code> 的项目，我们可以使用 <code>npm ci</code> 来替代 <code>npm install</code>.</p>
<!-- more -->
<h2 id="前言">前言</h2>
<p>在阅读本文之前，你应该先了解以下知识（点击链接可以快速了解相关知识）：</p>
<ul>
<li><a href="http://www.conardli.top/blog/article/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89npm%E5%8C%85%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%EF%BC%9F.html#%E5%AE%9A%E6%9C%9F%E6%9B%B4%E6%96%B0%E4%BE%9D%E8%B5%96">npm 依赖版本管理</a></li>
<li><a href="https://docs.taro.zone/docs/README">你至少应该知道Taro是什么</a>.</li>
</ul>
<h2 id="为什么使用-npm-ci">为什么使用 npm ci</h2>
<p>最近出现了Jenkins构建成功，但是项目却运行失败的情况，排查问题的时候发现是Jenkins构建时安装依赖的版本不对导致的构建失败。</p>
<p>本身这种情况发生的概率比较小，因为我们在安装依赖的时候默认都会在依赖的版本号前面加上 <code>^</code> 来限制安装依赖的大版本。</p>
<p>这次的问题是在安装 <code>Taro</code> 时版本的不对齐导致的。如果我们需要使用 <code>Taro</code> ，除了安装 <code>@tarojs/cli</code> 之外，我们还需要安装一些依赖（使用 <code>Taro CLI</code> 创建项目时会自动安装），比如：<code>@tarojs/components</code>、 <code>@tarojs/runtime</code>、 <code>@tarojs/taro</code>等等。</p>
<p><code>Taro</code> 要求我们在安装这些依赖的时候 <code>Taro CLI</code> 版本与项目中 <code>Taro</code> 相关依赖的版本保持一致，否则无法正常运行。关于这项规则的详情可以查阅<a href="https://nervjs.github.io/taro/blog/2020-09-01-taro-versions/#%E5%B0%86-taro-cli-%E7%89%88%E6%9C%AC%E4%B8%8E%E9%A1%B9%E7%9B%AE%E4%B8%AD-taro-%E7%9B%B8%E5%85%B3%E4%BE%9D%E8%B5%96%E7%9A%84%E7%89%88%E6%9C%AC%E4%BF%9D%E6%8C%81%E4%B8%80%E8%87%B4">Taro 官方文档</a>.</p>
<p>在我们的 <code>package.json</code> 中，我们只是使用了 <code>^</code> 来限制这些依赖的大版本更新，这样的限制对于 <code>Taro</code> 来说是不足够的。</p>
<p>原本我们的方案是去掉 <code>Taro</code> 相关依赖的前面的 <code>^</code>，这样这些依赖的版本就完全固定了，除非我们手动修改它，这样的方案当然是没有问题的。</p>
<p>但除此之外，我们应该还有另一个方案。别忘了，我们在本地运行和调试项目的时候是完全正常的，也就是说我们本地安装的依赖是没问题的。</p>
<p>所以另一个方案就是让 Jenkins 构建时安装和使用与我们本地相同的依赖，如果你说直接将 <code>node_modules</code> 推送到代码仓库中，这当然也能解决问题。但我不敢保证，你的同事听到你的这番言论会不会臭骂你两句，然后踹你一脚。</p>
<p>此时我们应该想到另一个可能被我们遗忘的小机灵鬼：<code>package-lock.json</code>。这可是控制 <code>node_modules</code> 文件夹中所有依赖的源头啊。</p>
<p>是的，我们完全可以通过锁定问题的源头来解决问题，即锁定 <code>package-lock.json</code>，让 Jenkins 在构建安装依赖时使用和我们本地依赖一致的包，这样我们的问题就可以解决了。</p>
<p>而实现这一目标的的一个优雅工具就是：<code>npm ci</code>.我们可以使用 <code>npm ci</code> 取代 <code>npm install</code>，就像图里所演示的这样，将构建脚本里的 <code>npm install</code> 换成 <code>npm ci</code>，这样就可以实现我们所需要的效果了：</p>
<figure data-type="image" tabindex="1"><img src="https://awhitemouse.github.io//post-images/1619501381269.png" alt="" loading="lazy"></figure>
<p>关于使用 <code>npm ci</code> 的场景，它应该是这样的：</p>
<blockquote>
<p>在有 <code>package-lock</code> 的项目，我们可以使用 <code>npm ci</code> 来替代 <code>npm install</code>.</p>
</blockquote>
<h2 id="npm-ci-vs-npm-install">npm ci vs npm install</h2>
<p>至于 <code>npm ci</code> 相较于 <code>npm install</code> 还有哪些区别与优势，可以参考这篇文章：<a href="https://blog.csdn.net/csdn_yudong/article/details/84929546">npm ci 命令</a>.这篇文章已经清晰地讲述了它们之间的联系。</p>
<h2 id="我是尾巴">我是尾巴</h2>
<p>当我写完这篇文章的时候，心里突然感觉非常的舒畅。这像是20世纪50年代里，在那个还只有黑白电影的年代，一位瘦高的英国绅士正站在剧幕正中的讲演台上侃侃而谈。</p>
<h2 id="参考链接">参考链接</h2>
<ol>
<li><a href="https://blog.csdn.net/csdn_yudong/article/details/84929546">npm ci 命令</a>.</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[css扩大元素的点击范围]]></title>
        <id>https://awhitemouse.github.io/post/css-kuo-da-yuan-su-de-dian-ji-fan-wei/</id>
        <link href="https://awhitemouse.github.io/post/css-kuo-da-yuan-su-de-dian-ji-fan-wei/">
        </link>
        <updated>2021-04-19T11:45:35.000Z</updated>
        <summary type="html"><![CDATA[<p>QA反映有个按钮有点难点到，但是UI稿设计的宽高就这么大啊，所以只能想办法在不改变元素展示样式的情况下扩大元素的点击范围。</p>
]]></summary>
        <content type="html"><![CDATA[<p>QA反映有个按钮有点难点到，但是UI稿设计的宽高就这么大啊，所以只能想办法在不改变元素展示样式的情况下扩大元素的点击范围。</p>
<!-- more -->
<p>有两种方案都可以实现我现在的需求，它们分别是：</p>
<ul>
<li>border + background</li>
<li>伪元素</li>
</ul>
<h2 id="方案一border-background-clip">方案一：border + background-clip</h2>
<p><code>background-clip</code>：设置元素的背景（背景图片或颜色）是否延伸到边框、内边距盒子、内容盒子下面。</p>
<pre><code class="language-css">.target {
    border: 20px solid transparent;
    background-clip: padding-box;
}
</code></pre>
<h2 id="方案二伪元素">方案二：伪元素</h2>
<p>不改变元素的大小，扩大其元素的大小。</p>
<pre><code class="language-css">.target {
    position: relative;
}

.target::after {
    position: absolute;
    top: -10px;
    right: -10px;
    bottom: -10px;
    left: -10px;
}
</code></pre>
<h2 id="总结">总结</h2>
<p>方案一虽然在展示效果上没有改变，但确实是改变了原始元素的大小，可能会引起一些不必要的问题。所以我<code>更推荐方案二</code>。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于儿童交互产品的设计理念]]></title>
        <id>https://awhitemouse.github.io/post/guan-yu-er-tong-jiao-hu-chan-pin-de-she-ji-li-nian/</id>
        <link href="https://awhitemouse.github.io/post/guan-yu-er-tong-jiao-hu-chan-pin-de-she-ji-li-nian/">
        </link>
        <updated>2021-04-15T02:39:52.000Z</updated>
        <summary type="html"><![CDATA[<p>今天早会的时候，产品总监提出目前我们的产品还是有一部分偏向于成人化。这让我好奇：成人交互与儿童交互的区别在哪里呢？</p>
]]></summary>
        <content type="html"><![CDATA[<p>今天早会的时候，产品总监提出目前我们的产品还是有一部分偏向于成人化。这让我好奇：成人交互与儿童交互的区别在哪里呢？</p>
<!-- more -->
<p>我在查找资料的过程中，发现了一篇文章：<a href="http://www.gx-id.com/new/265.html">不同年龄阶段儿童交互产品设计理念需要加以区分利用</a>，其中对于成人与儿童交互应有的区别的做了详细的论述：</p>
<figure data-type="image" tabindex="1"><img src="https://awhitemouse.github.io//post-images/1618454763745.png" alt="" loading="lazy"></figure>
<p>另外还有一篇文章：<a href="https://zhuanlan.zhihu.com/p/130241756">儿童和成人学习英语的区别</a>，其中关于儿童英语学习路径的观点可以参考一下：</p>
<figure data-type="image" tabindex="2"><img src="https://awhitemouse.github.io//post-images/1618454933806.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何绘制一条优雅的圆弧线]]></title>
        <id>https://awhitemouse.github.io/post/ru-he-hui-zhi-yi-tiao-you-ya-de-yuan-hu-xian/</id>
        <link href="https://awhitemouse.github.io/post/ru-he-hui-zhi-yi-tiao-you-ya-de-yuan-hu-xian/">
        </link>
        <updated>2021-04-12T12:55:19.000Z</updated>
        <summary type="html"><![CDATA[<p>最近在做的一个需求里需要绘制一条优雅的圆弧线，UE问我要不要切图？？伤害性不大，侮辱性极强！</p>
]]></summary>
        <content type="html"><![CDATA[<p>最近在做的一个需求里需要绘制一条优雅的圆弧线，UE问我要不要切图？？伤害性不大，侮辱性极强！</p>
<!-- more -->
<p>UE给出的设计稿是下面这样的👇（看中间的那条白色圆弧线）</p>
<figure data-type="image" tabindex="1"><img src="https://awhitemouse.github.io//post-images/1618456618748.png" alt="" loading="lazy"></figure>
<p>跟UE对设计稿的时候，UE问我这个圆弧要不要切图？<del><em>嗯!? 这么简单的圆弧还切图，看不起谁呢？</em><del></p>
<p>👀之前也绘制过圆弧线，是使用 <a href="#%E7%94%BB%E5%A4%A7%E5%9C%86">画大圆</a> 的方式实现的。而这一次，我突然想到应该还有其他的办法也可以实现相同的效果吧。</p>
<p>于是查阅了一些资料，结合自身的经验总结了有如下几种画圆弧的方式：</p>
<ul>
<li>画大圆</li>
<li>定制border-radius</li>
<li>box-shadow</li>
<li>transform：scaleX/Y</li>
<li>svg</li>
<li>canvas</li>
<li>图片</li>
</ul>
<h2 id="画大圆">画大圆</h2>
<p>画大圆是最直接的实现方案了，也应该是很多开发者首先想到的方案之一了。</p>
<p>需要注意的地方是外部容器需要 <code>overflow: hidden</code> 用于隐藏圆形超过容器的部分。</p>
<iframe height="474" style="width: 100%;" scrolling="no" title="绘制圆弧 - 画大圆" src="https://codepen.io/awhitemouse/embed/gOgzpvX?height=265&theme-id=dark&default-tab=css,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href='https://codepen.io/awhitemouse/pen/gOgzpvX'>绘制圆弧 - 画大圆</a> by chenxin
  (<a href='https://codepen.io/awhitemouse'>@awhitemouse</a>) on <a href='https://codepen.io'>CodePen</a>.
</iframe>
<br>
<h2 id="定制border-radius">定制border-radius</h2>
<p>我们常用 <code>border-radius</code> 画圆角，或者是画一个圆形。使用方法大概是这样的：</p>
<pre><code class="language-css">.demo {
    border-radius: 4px;
    /* or */
    border-radius: 50%;
}
</code></pre>
<p>而这里的定制  <code>border-radius</code> 使用了它的一项不常用的技能：为每一个单边设置圆角。</p>
<pre><code class="language-css">.demo {
    border-radius: 0 12px 12px 0 / 0 50% 50% 0;
}
</code></pre>
<p>这里不详细描述关于定制 <code>border-radius</code> 的内容，详细了解可以参考这篇文章：<a href="https://juejin.cn/post/6844903693423214600">border-radius结合动画创建酷炫的效果</a>.</p>
<p>从下方的演示效果看，越靠近两端，边框被压缩得越细，这与我们想要的效果还是有一定差别的。</p>
<iframe height="474" style="width: 100%;" scrolling="no" title="绘制圆弧 - 定制border-radius" src="https://codepen.io/awhitemouse/embed/NWdMqNy?height=265&theme-id=dark&default-tab=css,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href='https://codepen.io/awhitemouse/pen/NWdMqNy'>绘制圆弧 - 定制border-radius</a> by chenxin
  (<a href='https://codepen.io/awhitemouse'>@awhitemouse</a>) on <a href='https://codepen.io'>CodePen</a>.
</iframe>
<br>
<h2 id="box-shadow">box-shadow</h2>
<p>关于 <code>box-shadow</code> 的方案，仔细对比下方的代码和 <a href="#%E5%AE%9A%E5%88%B6border-radius">定制border-radius</a> 的代码可以发现，其实就是将白色边框的绘制方式从 <code>border-right</code> 换成了<code>box-shadow</code>。</p>
<p>更换以后解决了 <a href="#%E5%AE%9A%E5%88%B6border-radius">定制border-radius</a> 方案中提到的边框压缩的问题，但是这个方案绘制出来的圆弧并不够圆润，并没有达到我所想要的效果。</p>
<iframe height="474" style="width: 100%;" scrolling="no" title="绘制圆弧 - box-shadow" src="https://codepen.io/awhitemouse/embed/xxgjwxR?height=265&theme-id=dark&default-tab=css,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href='https://codepen.io/awhitemouse/pen/xxgjwxR'>绘制圆弧 - box-shadow</a> by chenxin
  (<a href='https://codepen.io/awhitemouse'>@awhitemouse</a>) on <a href='https://codepen.io'>CodePen</a>.
</iframe>
<br>
<h2 id="transformscalexy">transform：scaleX/Y</h2>
<p>这个方案还挺有趣的，通过旋转的方式从视觉效果上改变了圆角的大小。</p>
<p>但是我简单写了一个demo之后就发现，这个方案的产生的问题跟 <a href="#%E5%AE%9A%E5%88%B6border-radius">定制border-radius</a> 方案产生的问题相同。</p>
<iframe height="265" style="width: 100%;" scrolling="no" title="绘制圆弧 - transfrom" src="https://codepen.io/awhitemouse/embed/vYgjxjB?height=265&theme-id=dark&default-tab=css,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href='https://codepen.io/awhitemouse/pen/vYgjxjB'>绘制圆弧 - transfrom</a> by chenxin
  (<a href='https://codepen.io/awhitemouse'>@awhitemouse</a>) on <a href='https://codepen.io'>CodePen</a>.
</iframe>
<br>
<h2 id="svg">svg</h2>
<p>使用 <code>svg</code> 的方案无论从使用方法还是从展示效果上，跟 <a href="#%E7%94%BB%E5%A4%A7%E5%9C%86">#画大圆</a> 效果是相同的。</p>
<iframe height="474" style="width: 100%;" scrolling="no" title="绘制圆弧 - svg" src="https://codepen.io/awhitemouse/embed/VwPxpxo?height=265&theme-id=dark&default-tab=html,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href='https://codepen.io/awhitemouse/pen/VwPxpxo'>绘制圆弧 - svg</a> by chenxin
  (<a href='https://codepen.io/awhitemouse'>@awhitemouse</a>) on <a href='https://codepen.io'>CodePen</a>.
</iframe>
<br>
<h2 id="canvas">canvas</h2>
<p>而 <code>canvas</code> 的方案与 <a href="#svg">svg 方案</a> 实现方法也是类似的，同样是绘制一个大圆环，然后使用 <code>overflow: hidden</code> 隐藏掉了溢出的部分。<em>也可以只绘制需要显示的一部分圆弧，只需要调整绘制圆弧的起始角度和终止角度即可</em>。</p>
<iframe height="474" style="width: 100%;" scrolling="no" title="绘制圆弧 - canvas" src="https://codepen.io/awhitemouse/embed/BapxZPe?height=265&theme-id=dark&default-tab=js,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href='https://codepen.io/awhitemouse/pen/BapxZPe'>绘制圆弧 - canvas</a> by chenxin
  (<a href='https://codepen.io/awhitemouse'>@awhitemouse</a>) on <a href='https://codepen.io'>CodePen</a>.
</iframe>
<br>
<h2 id="总结">总结</h2>
<p>方案罗列完毕之后就该选择方案了，从实际展示效果上进行筛选的话，可以达到操作效果的是<a href="#%E7%94%BB%E5%A4%A7%E5%9C%86">画大圆</a>、<a href="#svg">svg</a>、<a href="#canvas">canvas</a>。</p>
<p>我当前这个需求所基于的场景时小程序，小程序对 <code>svg</code> 的兼容程度并不好，而 <code>canvas</code> 无论从操作难度还是性能上，跟纯css是无法相提并论的。</p>
<p>所以最终还是选择了 <a href="#%E7%94%BB%E5%A4%A7%E5%9C%86">画大圆</a> 的解决方案。<del><em>绕了一圈又回来了</em></del></p>
<h2 id="我是尾巴">我是尾巴</h2>
<p>本文一共列举了 7 中绘制圆弧的方式，如果你还有更优的方案，或者对本文提出的方案有异议，请在评论区提出，谢谢。</p>
<h2 id="参考">参考</h2>
<ol>
<li><a href="https://zhuanlan.zhihu.com/p/28142155">网页中弧线的几种实现方法</a>.</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何做一场高质量的分享]]></title>
        <id>https://awhitemouse.github.io/post/ru-he-zuo-yi-chang-gao-zhi-liang-de-fen-xiang/</id>
        <link href="https://awhitemouse.github.io/post/ru-he-zuo-yi-chang-gao-zhi-liang-de-fen-xiang/">
        </link>
        <updated>2021-04-02T03:52:08.000Z</updated>
        <summary type="html"><![CDATA[<p>最近做了两次分享，第二次分享完之后，自我感觉不是很理想。正好看到这样一篇分析高质量分享的<a href="https://mp.weixin.qq.com/s/ZcHkIs00kVeyZ2-7u3cg5A">文章</a>，看完之后确有所得，所以这里对这篇文章里提到的自己踩过坑的地方列出来，结合自己的经历做一个总结。</p>
]]></summary>
        <content type="html"><![CDATA[<p>最近做了两次分享，第二次分享完之后，自我感觉不是很理想。正好看到这样一篇分析高质量分享的<a href="https://mp.weixin.qq.com/s/ZcHkIs00kVeyZ2-7u3cg5A">文章</a>，看完之后确有所得，所以这里对这篇文章里提到的自己踩过坑的地方列出来，结合自己的经历做一个总结。</p>
<!-- more -->
<p>在每次分享之前都需要先反思以下几点：</p>
<h2 id="为什么要分享">为什么要分享</h2>
<p>做一次分享最重要的前提是知道为什么要做这次分享，其他伙伴能从这次分享中学习到什么呢？</p>
<blockquote>
<p>分享的本意就是总结并传播知识，分享的核心是利他。</p>
</blockquote>
<p>切忌为了展示自己的优秀而分享。</p>
<h2 id="什么是好的内容">什么是好的内容</h2>
<blockquote>
<p>高度总结的知识<br>
可以借鉴的经验：建设经验、推导过程……<br>
晦涩难懂的技术：深入浅出</p>
</blockquote>
<p>听众都比较熟识或者上网一查就能马上查到的内容就不要专门拿出来分享了，自己讲起来也没有底气，听众也没有兴趣听下去。</p>
<p>对于技术分享，如果把知识分为<code>基础</code>、 <code>进阶</code> 和 <code>精深</code> 三个阶段的话，分享的主题最好属于 <code>进阶</code> 和 <code>精深</code> 这两个阶段。</p>
<h2 id="如何去组织内容">如何去组织内容</h2>
<ol>
<li>结构性</li>
</ol>
<p>内容的讲解形式最好是总分总，即 <code>结论 -&gt; 论证讲解 -&gt; 总结</code> 三步走。</p>
<p>首先讲解结论，让听众先了解自己要讲什么内容。最后总结，帮助归纳总结， 加深听众对于内容的记忆深度。</p>
<ol start="2">
<li>故事性</li>
</ol>
<p>能把内容像讲故事一样讲出来当然更好，讲故事这方面不行的话就算了。</p>
<h2 id="如何去展示内容">如何去展示内容</h2>
<blockquote>
<p>少字多图！切忌念稿子！</p>
</blockquote>
<h2 id="如何去表达内容">如何去表达内容</h2>
<blockquote>
<p>吸引人的开场<br>
与观众有互动<br>
有停顿有节奏</p>
</blockquote>
<h2 id="必要条件">必要条件</h2>
<blockquote>
<p>保证质量！</p>
</blockquote>
<h2 id="参考">参考</h2>
<ol>
<li><a href="https://mp.weixin.qq.com/s/ZcHkIs00kVeyZ2-7u3cg5A">如何做一场高质量的分享</a>.</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何拦截Elementui RadioGroup的数据变更]]></title>
        <id>https://awhitemouse.github.io/post/ru-he-lan-jie-elementui-raio-group-de-shu-ju-bian-geng/</id>
        <link href="https://awhitemouse.github.io/post/ru-he-lan-jie-elementui-raio-group-de-shu-ju-bian-geng/">
        </link>
        <updated>2021-03-30T02:00:12.000Z</updated>
        <summary type="html"><![CDATA[<p>最近在做的一个业务场景需要劫持掉 <code>RadioGroup</code> 的内部的数据自动更新行为，然后根据外部的条件动态判断能否更新数据。</p>
]]></summary>
        <content type="html"><![CDATA[<p>最近在做的一个业务场景需要劫持掉 <code>RadioGroup</code> 的内部的数据自动更新行为，然后根据外部的条件动态判断能否更新数据。</p>
<!-- more -->
<h2 id="问题简述">问题简述</h2>
<p>界面如下图。最上方的Tabs标签页是一级分类（Tabs）；中间的按钮组（即RadioGroup）是二级分类；下方是数据展示面板，用于展示当前分类下的数据。</p>
<figure data-type="image" tabindex="1"><img src="https://awhitemouse.github.io//post-images/1617161503433.png" alt="" loading="lazy"></figure>
<p>如果数据展示面板被手动操作导致数据发生更改后，此时去切换上方的一级分类或者二级分类都需要弹出二次确认弹窗如下：</p>
<figure data-type="image" tabindex="2"><img src="https://awhitemouse.github.io//post-images/1617161868698.png" alt="" loading="lazy"></figure>
<h2 id="解决方案">解决方案</h2>
<p>我们的使用的组件库是<a href="https://element.eleme.cn/#/zh-CN/component/installation">element-ui 2</a>。</p>
<p>下面将针对不同的组件提出不同的数据劫持的方案。</p>
<h3 id="一级分类tabs">一级分类：Tabs</h3>
<p>Tabs组件提供了 <code>before-leave</code> 钩子，可以使用这个钩子完成对数据变更的劫持。</p>
<figure data-type="image" tabindex="3"><img src="https://awhitemouse.github.io//post-images/1617162183098.png" alt="" loading="lazy"></figure>
<p>使用示例如下：<br>
<img src="https://awhitemouse.github.io//post-images/1617162565503.png" alt="" loading="lazy"><br>
<img src="https://awhitemouse.github.io//post-images/1617162382412.png" alt="" loading="lazy"></p>
<h3 id="二级分类radiogroup">二级分类：RadioGroup</h3>
<p>相较于Tabs，RadioGroup的处理方案要复杂一些，因为这个组件并没有提供类似于 <code>before-leave</code> 的钩子，所以需要自行实现这一过程。</p>
<p>最初的想法是利用官方提供的 <code>value</code> 属性以及<code>chang</code>回调来完成这一过程。因为如果用 <code>v-model</code> 的话，Vue内部就会代理所有的数据处理，就不能完成自定义的数据劫持了。</p>
<figure data-type="image" tabindex="4"><img src="https://awhitemouse.github.io//post-images/1617163290456.png" alt="" loading="lazy"></figure>
<p>关键代码如下：</p>
<pre><code class="language-html">&lt;template&gt;
    &lt;el-tabs v-model=&quot;activeLevelGroup&quot; :before-leave=&quot;beforeLeave&quot; :class=&quot;$style['tabs']&quot;&gt;
        &lt;el-tab-pane
            v-for=&quot;key in bigCatLevelManage&quot;
            :key=&quot;key&quot;
            :label=&quot;BigCatLevelGroupName[key]&quot;
            :name=&quot;`${key}`&quot;
        &gt;
            &lt;!-- FIXME: value + change --&gt;
            &lt;el-radio-group :value=&quot;activeLevel&quot; size=&quot;small&quot; @change=&quot;onRadioChange&quot;&gt;
                &lt;el-radio-button
                    v-for=&quot;level in BigCatLevelManage[key]&quot;
                    :key=&quot;level&quot;
                    :label=&quot;level&quot;
                    :data-level=&quot;level&quot;
                &gt;
                    {{BigCatBookLevelName[level]}}
                &lt;/el-radio-button&gt;
            &lt;/el-radio-group&gt;
        &lt;/el-tab-pane&gt;
    &lt;/el-tabs&gt;
&lt;/template&gt;

&lt;script lang=&quot;ts&quot;&gt;
import {Vue, Prop, Component, Watch} from 'vue-property-decorator';

@Component
export default class LevelTab extends Vue {
    activeLevel = 0;

    onRadioChange(value) {
        // 这里拦截数据变更
        if (this.allowChange) {
            this.activeLevel = value;
        }
        else {
            // ……
        }
    }
}
&lt;/script&gt;
</code></pre>
<p>当我兴高采烈地去运行代码的时候发现实际效果与预想的效果差的十万八千里。</p>
<p>无论我点选哪个选项，该选项都会被点亮，并且再次点击也无法取消选中……😰</p>
<figure data-type="image" tabindex="5"><img src="https://awhitemouse.github.io//post-images/1617172179228.png" alt="" loading="lazy"></figure>
<p>到这里，继续靠推测去研究方案效率就很低了。不如干脆去看看element-ui 源码，看看<a href="https://github.com/ElemeFE/element/blob/dev/packages/radio/src/radio-group.vue">RadioGroup</a>和<a href="https://github.com/ElemeFE/element/blob/dev/packages/radio/src/radio-button.vue">RadioButton</a>的数据是怎么传递和更新的.</p>
<h2 id="radiogroup-与-radiobutton">RadioGroup 与 RadioButton</h2>
<p>先看了 RadioGroup 的源码，只在 <code>created</code> 钩子里看见了数据处理相关的代码。它监听了 <code>handleChange</code> 事件，并在监听到该事件后向上层发送 <code>change</code> 回调。</p>
<pre><code class="language-js">created() {
    this.$on('handleChange', value =&gt; {
        this.$emit('change', value);
    });
},
</code></pre>
<p>RadioGroup 没有更多关于数据处理的代码了，那么玄机就应该在 RadioButton 的源码里了，这里先贴一下 RadioButton 代码里有关数据处理的部分。</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;label
    class=&quot;el-radio-button&quot;
    :class=&quot;[
      size ? 'el-radio-button--' + size : '',
      { 'is-active': value === label },
      { 'is-disabled': isDisabled },
      { 'is-focus': focus }
    ]&quot;
    role=&quot;radio&quot;
    :aria-checked=&quot;value === label&quot;
    :aria-disabled=&quot;isDisabled&quot;
    :tabindex=&quot;tabIndex&quot;
    @keydown.space.stop.prevent=&quot;value = isDisabled ? value : label&quot;
  &gt;
    &lt;input
      class=&quot;el-radio-button__orig-radio&quot;
      :value=&quot;label&quot;
      type=&quot;radio&quot;
      v-model=&quot;value&quot;
      :name=&quot;name&quot;
      @change=&quot;handleChange&quot;
      :disabled=&quot;isDisabled&quot;
      tabindex=&quot;-1&quot;
      @focus=&quot;focus = true&quot;
      @blur=&quot;focus = false&quot;
    &gt;
    &lt;span
      class=&quot;el-radio-button__inner&quot;
      :style=&quot;value === label ? activeStyle : null&quot;
      @keydown.stop&gt;
      &lt;slot&gt;&lt;/slot&gt;
      &lt;template v-if=&quot;!$slots.default&quot;&gt;{{label}}&lt;/template&gt;
    &lt;/span&gt;
  &lt;/label&gt;
&lt;/template&gt;
&lt;script&gt;
  import Emitter from 'element-ui/src/mixins/emitter';

  export default {
    name: 'ElRadioButton',

    mixins: [Emitter],
    
    computed: {
      // **注意这里**
      value: {
        get() {
          return this._radioGroup.value;
        },
        set(value) {
          this._radioGroup.$emit('input', value);
        }
      },
      _radioGroup() {
        let parent = this.$parent;
        while (parent) {
          if (parent.$options.componentName !== 'ElRadioGroup') {
            parent = parent.$parent;
          } else {
            return parent;
          }
        }
        return false;
      },
    },

    methods: {
      handleChange() {
        this.$nextTick(() =&gt; {
          this.dispatch('ElRadioGroup', 'handleChange', this.value);
        });
      }
    }
  };
&lt;/script&gt;
</code></pre>
<p>从源码里可以看到，内部是使用 <code>&lt;input type=&quot;radio&quot; /&gt;</code> 实现的单选按钮。</p>
<p>当我们的使用了 <code>value</code> 来传递数据时，可以监听 <code>input</code> 回调来劫持数据的更改。</p>
<p>然后当我使用 <code>value</code> + <code>input</code> 的组合时，展示效果依然跟上面一样，所有的选项都会被点亮。我用Vue devtools查看数据的时候发现，数据传递确实中断了。而我所看到的<strong>点亮</strong>的效果，居然是 <code>input:checked</code> 样式造成的，而不是数据。</p>
<p>那么想要用 <code>value</code> 就必须要消除 <code>input</code> 的 <code>checked</code> 状态对样式的影响。所以当前最佳的办法就是自定义 <code>click</code> 方法，然后使用 <code>.prevent</code> 修饰符来屏蔽掉内部的点击事件。</p>
<h2 id="劫持radiogroup终极方案">“劫持”RadioGroup终极方案</h2>
<pre><code class="language-html">&lt;template&gt;
    &lt;el-tabs v-model=&quot;activeLevelGroup&quot; :before-leave=&quot;beforeLeave&quot; :class=&quot;$style['tabs']&quot;&gt;
        &lt;el-tab-pane
            v-for=&quot;key in bigCatLevelManage&quot;
            :key=&quot;key&quot;
            :label=&quot;BigCatLevelGroupName[key]&quot;
            :name=&quot;`${key}`&quot;
        &gt;
            &lt;el-radio-group :value=&quot;activeLevel&quot; size=&quot;small&quot;&gt;
                &lt;!-- NOTE：这里拦截了radio-button的向上冒泡。主要为了实现数据切换前进行一系列的判断 --&gt;
                &lt;el-radio-button
                    v-for=&quot;level in BigCatLevelManage[key]&quot;
                    :key=&quot;level&quot;
                    :label=&quot;level&quot;
                    :data-level=&quot;level&quot;
                    @click.native.prevent=&quot;handeClickRadio(level)&quot;
                &gt;
                    {{BigCatBookLevelName[level]}}
                &lt;/el-radio-button&gt;
            &lt;/el-radio-group&gt;
        &lt;/el-tab-pane&gt;
    &lt;/el-tabs&gt;
&lt;/template&gt;

&lt;script lang=&quot;ts&quot;&gt;
import {Vue, Prop, Component, Watch} from 'vue-property-decorator';

@Component
export default class LevelTab extends Vue {

    activeLevel =0;

    // 拦截radio-button向上冒泡，用于判断当前是否允许切换选项
    handeClickRadio(level: BigCatBookLevel) {
        // 如果当前点击的radio已经是选中状态，则不作处理
        if (level === this.activeLevel) {
            return;
        }
        this.beforeLeave().then(() =&gt; {
            this.activeLevel = level;
        });
    }
}
&lt;/script&gt;
</code></pre>
<h2 id="我是尾巴">我是尾巴</h2>
<p>至此，问题总算解决了，这也感谢其他小伙伴的帮助。</p>
<p>遇到这种问题的时候，还是要多看源码是怎么设计的，从里面寻找突破口。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GitHub Action: The process '/usr/bin/git' failed with exit code 128]]></title>
        <id>https://awhitemouse.github.io/post/github-action-gou-jian-shi-bai-chu-li/</id>
        <link href="https://awhitemouse.github.io/post/github-action-gou-jian-shi-bai-chu-li/">
        </link>
        <updated>2021-03-24T01:55:07.000Z</updated>
        <content type="html"><![CDATA[<p>最近发现了<a href="https://vuepress-theme-hope.github.io/zh">vuepress-theme-hope</a>这个强大的静态博客生成工具，它使用了<code>GitHub Action</code>来构建生成静态网页，但是在我发布代码之后，构建了好几次都没有成功。</p>
<h2 id="问题">问题</h2>
<p>错误日志：</p>
<blockquote>
<p>The process '/usr/bin/git' failed with exit code 128.</p>
</blockquote>
<p>截图：</p>
<figure data-type="image" tabindex="1"><img src="https://awhitemouse.github.io//post-images/1616550964478.png" alt="" loading="lazy"></figure>
<p>构建脚本：</p>
<pre><code class="language-yml">name: Deploy GitHub Pages

on:
  push:
    branches:
      - master

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v2
        with:
          persist-credentials: false

      - uses: actions/cache@v2.1.4
        id: node-modules
        with:
          path: node_modules/
          key: ${{ runner.os }}-node-modules-${{ hashFiles('yarn.lock') }}
          restore-keys: |
            ${{ runner.os }}-node-modules-

      - name: Install Deps
        if: steps.node-modules.outputs.cache-hit != 'true'
        run: yarn install --frozen-lockfile

      - name: Build Template
        run: yarn run build

      - name: Deploy
        uses: JamesIves/github-pages-deploy-action@releases/v3
        with:
          ACCESS_TOKEN: ${{ secrets.ACCESS_TOKEN }}
          BRANCH: gh-pages
          FOLDER: dist
</code></pre>
<h2 id="处理">处理</h2>
<p>经过多次的尝试，最后找到的原因是没有配置 <code>GITHUB_TOKEN</code> 属性。</p>
<p>配置以后的代码是这样的</p>
<pre><code class="language-yml">name: Deploy GitHub Pages

on:
  push:
    branches:
      - master

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v2
        with:
          persist-credentials: false

      - uses: actions/cache@v2.1.4
        id: node-modules
        with:
          path: node_modules/
          key: ${{ runner.os }}-node-modules-${{ hashFiles('yarn.lock') }}
          restore-keys: |
            ${{ runner.os }}-node-modules-

      - name: Install Deps
        if: steps.node-modules.outputs.cache-hit != 'true'
        run: yarn install --frozen-lockfile

      - name: Build Template
        run: yarn run build

      - name: Deploy
        uses: JamesIves/github-pages-deploy-action@releases/v3
        with:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}   /* 注意：这行是新加的 */
          ACCESS_TOKEN: ${{ secrets.ACCESS_TOKEN }}
          BRANCH: gh-pages
          FOLDER: dist
</code></pre>
<p>大功告成。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[为什么要在function之前加上"!"]]></title>
        <id>https://awhitemouse.github.io/post/wei-shi-me-yao-zai-function-zhi-qian-jia-shang/</id>
        <link href="https://awhitemouse.github.io/post/wei-shi-me-yao-zai-function-zhi-qian-jia-shang/">
        </link>
        <updated>2021-03-19T09:51:28.000Z</updated>
        <summary type="html"><![CDATA[<p>在某些第三方包中，会见到以 <code>!</code> 开头的代码，那么为什么要这么做呢？</p>
]]></summary>
        <content type="html"><![CDATA[<p>在某些第三方包中，会见到以 <code>!</code> 开头的代码，那么为什么要这么做呢？</p>
<!-- more -->
<p>这种代码的框架是这样的：</p>
<pre><code class="language-js">!function() {

}();
</code></pre>
<p>以这样的形式展现，可能不容易看出来是怎么回事，这么写的用意是什么？</p>
<p>接下来再看另外一个常见的第三方包的导出代码形式：</p>
<pre><code class="language-js">(function() {

})()
</code></pre>
<p>其实， <code>!</code> 的作用跟 <code>()</code> 的作用相同，都是将后面的部分解析成函数表达式去执行。</p>
<p>同样作用的还有 <code>~</code>、<code>+</code>、<code>-</code> 等等。</p>
<h2 id="参考">参考</h2>
<ol>
<li><a href="https://swordair.com/function-and-exclamation-mark/">function与感叹号</a>.</li>
<li><a href="https://segmentfault.com/q/1010000000117476">javascript里function之前加上感叹号 ' ! ' 会怎么样？</a>.</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JS实现字符串的批量替换]]></title>
        <id>https://awhitemouse.github.io/post/js-shi-xian-zi-fu-chuan-de-pi-liang-ti-huan/</id>
        <link href="https://awhitemouse.github.io/post/js-shi-xian-zi-fu-chuan-de-pi-liang-ti-huan/">
        </link>
        <updated>2021-03-15T07:26:33.000Z</updated>
        <content type="html"><![CDATA[<p>有一个对象数据结构如下：</p>
<pre><code class="language-js">obj = {
    content: '准备将#网址导航项目#由静态网页项目改装为#React项目#，减少重复代码。',
    links: ['https://github.com/WebStackPage/WebStackPage.github.io', 'http: //www.baidu.com'],
}
</code></pre>
<p>现在需要使用原生JS完成字符串替换工作：找到<code>content</code>中使用<code>#</code>号标识符包裹的字符串，将其改成使用<code>a标签</code>包裹，<code>a标签</code>的<code>href</code>依次使用<code>links</code>中的数据项。</p>
<p>替换后的结果应如下：</p>
<pre><code class="language-html">准备将&lt;a href=&quot;https://github.com/WebStackPage/WebStackPage.github.io&quot;&gt;网址导航项目&lt;/a&gt;由静态网页项目改装为&lt;a href=&quot;http://baidu.com&quot;&gt;React项目&lt;/a&gt;，减少重复代码。
</code></pre>
<h2 id="实现">实现</h2>
<pre><code class="language-js">// 先将字符串拆解
const textArr = a.content.split('#');
// 最后的结果
let result = '';
// 标志位：用于判断当前应该添加开标签还是闭标签
let flag = 0;
// 如果第一个字符就是#号，那么从第一个字符开始添加开标签
if (a.content[0] === '#') {
    result += '&lt;a href=&quot;' + a.links[0] + '&quot;&gt;';
    flag = ~flag;
}
textArr.forEach((text, index) =&gt; {
    if (flag) {
        // 如果已经添加过开标签，则现在应该添加标签
        result += text + '&lt;/a&gt;';
    }
    else if (index !== textArr.length - 1) {
        // 如果前一个添加的标签是闭标签，并且当前不是数组的最后一个数据，则添加开标签
        result += text + '&lt;a href=&quot;' + a.links[index / 2] + '&quot;&gt;';
    }
    else {
        // 最后一个数据项，前一个添加的是闭标签，则直接连接文本
        result += text;
    }
    // 每次连接文本都更改一下标志位
    flag = ~flag;
})
console.log(result);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git 提交部分代码]]></title>
        <id>https://awhitemouse.github.io/post/git-ti-jiao-bu-fen-dai-ma/</id>
        <link href="https://awhitemouse.github.io/post/git-ti-jiao-bu-fen-dai-ma/">
        </link>
        <updated>2021-03-11T07:40:28.000Z</updated>
        <content type="html"><![CDATA[<p>如果我们开发过程中，需要先提交一部分代码，该怎么做呢？</p>
<h2 id="关键步骤">关键步骤</h2>
<pre><code class="language-shell">git add demo.html // 提交到暂存区
git stash -u -k  // 忽略其他修改，关键一步
git commit -m '修改演示文件' // 提交暂存区
git pull // 拉取合并
git push origin master // 推到远程仓库
git stash pop // 恢复之前忽略的文件（非常重要的一步）
</code></pre>
<h2 id="参考链接">参考链接</h2>
<ol>
<li><a href="https://blog.csdn.net/DongFuPanda/article/details/104246064">git 只提交部分文件到远程仓库</a>.</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Redux与Vuex的区别]]></title>
        <id>https://awhitemouse.github.io/post/redux-yu-vuex-de-qu-bie/</id>
        <link href="https://awhitemouse.github.io/post/redux-yu-vuex-de-qu-bie/">
        </link>
        <updated>2021-03-08T08:51:17.000Z</updated>
        <content type="html"><![CDATA[<h2 id="相同点">相同点</h2>
<ol>
<li>唯一的数据源</li>
<li>全局注入store</li>
</ol>
<h2 id="不同点">不同点</h2>
<ol>
<li>vuex直接修改原来的数据；redux根据原来的数据进行计算后返回新的数据</li>
<li>vuex定义了 state 、getter 、mutation 、 action四个对象；redux定义了state  、 reducer 、 action三个对象</li>
<li>vuex中mutation用于同步操作，action用于异步操作；redux中action既用于同步操作，也用于异步操作，用于异步操作时需要引入引入第三方包（redux-thunk\redux-saga）</li>
<li>vuex使用commit派发同步方法，dispatch派发异步方法；redux都用dispatch派发</li>
<li>vuex使用mutation修改状态；redux使用reducer修改状态</li>
</ol>
<h2 id="参考链接">参考链接</h2>
<ol>
<li><a href="https://lq782655835.github.io/blogs/react/diff-vuex-redux.html">Vuex与Redux比较</a>.</li>
<li><a href="https://juejin.cn/post/6844903929063424013">Redux 和 Vuex 的对比</a>.</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[腾讯移动端开发规范]]></title>
        <id>https://awhitemouse.github.io/post/teng-xun-yi-dong-duan-kai-fa-gui-fan/</id>
        <link href="https://awhitemouse.github.io/post/teng-xun-yi-dong-duan-kai-fa-gui-fan/">
        </link>
        <updated>2021-02-20T07:33:47.000Z</updated>
        <content type="html"><![CDATA[<p>要考虑Android低端机与2G网络场景下性能 <code>注意！</code></p>
<h3 id="发布前必要检查项">发布前必要检查项</h3>
<ul>
<li>所有图片必须有进行过压缩</li>
<li>考虑适度的有损压缩，如转化为80%质量的jpg图片</li>
<li>考虑把大图切成多张小图，常见在banner图过大的场景</li>
</ul>
<h3 id="加载性能优化-达到打开足够快">加载性能优化, 达到打开足够快</h3>
<ul>
<li>数据离线化，考虑将数据缓存在 localStorage</li>
<li>初始请求资源数 &lt; 4 注意！</li>
<li>图片使用CSS Sprites 或 DataURI</li>
<li>外链 CSS 中避免 @import 引入</li>
<li>考虑内嵌小型的静态资源内容</li>
<li>初始请求资源gzip后总体积 &lt; 50kb</li>
<li>静态资源(HTML/CSS/JS/Image)是否优化压缩？</li>
<li>避免打包大型类库</li>
<li>确保接入层已开启Gzip压缩（考虑提升Gzip级别，使用CPU开销换取加载时间）<code>注意！</code></li>
<li>尽量使用CSS3代替图片</li>
<li>初始首屏之外的静态资源（JS/CSS）延迟加载 <code>注意！</code></li>
<li>初始首屏之外的图片资源按需加载（判断可视区域） <code>注意！</code></li>
<li>单页面应用(SPA)考虑延迟加载非首屏业务模块</li>
<li>开启Keep-Alive链路复用</li>
</ul>
<h3 id="运行性能优化-达到操作足够流畅">运行性能优化, 达到操作足够流畅</h3>
<ul>
<li>避免 iOS 300+ms 点击延时问题 <code>注意！</code></li>
<li>缓存 DOM 选择与计算</li>
<li>避免触发页面重绘的操作</li>
<li>Debounce连续触发的事件(scroll / resize / touchmove等)，避免高频繁触发执行 <code>注意！</code></li>
<li>尽可能使用事件代理，避免批量绑定事件</li>
<li>使用CSS3动画代替JS动画</li>
<li>避免在低端机上使用大量CSS3渐变阴影效果，可考虑降级效果来提升流畅度</li>
<li>HTML结构层级保持足够简单</li>
<li>尽能少的使用CSS高级选择器与通配选择器</li>
<li>Keep it simple</li>
</ul>
<h2 id="参考链接">参考链接</h2>
<ol>
<li><a href="http://alloyteam.github.io/Spirit/modules/Standard/index.html">移动开发规范概述</a>.</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Chrome浏览器截长屏]]></title>
        <id>https://awhitemouse.github.io/post/chrome-liu-lan-qi-jie-chang-ping/</id>
        <link href="https://awhitemouse.github.io/post/chrome-liu-lan-qi-jie-chang-ping/">
        </link>
        <updated>2021-02-15T03:26:27.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://awhitemouse.github.io//post-images/1613359611986.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[微信小程序字体加载缓慢的问题]]></title>
        <id>https://awhitemouse.github.io/post/wei-xin-xiao-cheng-xu-zi-ti-jia-zai-huan-man-de-wen-ti/</id>
        <link href="https://awhitemouse.github.io/post/wei-xin-xiao-cheng-xu-zi-ti-jia-zai-huan-man-de-wen-ti/">
        </link>
        <updated>2021-01-12T02:13:52.000Z</updated>
        <content type="html"><![CDATA[<p>使用小程序自带的字体加载api辅助字体加载。</p>
<h2 id="解决方案">解决方案</h2>
<pre><code class="language-js">wx.loadFontFace({
    global: true,
    family: 'Bitstream Vera Serif Bold',
    source: 'url(&quot;https://sungd.github.io/Pacifico.ttf&quot;)',
    success: console.log
})
</code></pre>
<h2 id="参考链接">参考链接</h2>
<ol>
<li><a href="https://developers.weixin.qq.com/miniprogram/dev/api/ui/font/wx.loadFontFace.html">wx.loadFontFace</a>.</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[小程序多次点击会多次跳转页面问题]]></title>
        <id>https://awhitemouse.github.io/post/xiao-cheng-xu-duo-ci-dian-ji-hui-duo-ci-tiao-zhuan-ye-mian-wen-ti/</id>
        <link href="https://awhitemouse.github.io/post/xiao-cheng-xu-duo-ci-dian-ji-hui-duo-ci-tiao-zhuan-ye-mian-wen-ti/">
        </link>
        <updated>2021-01-11T14:49:29.000Z</updated>
        <summary type="html"><![CDATA[<p>目前可以想到的方案有两种：</p>
<ol>
<li>通过变量进行控制；</li>
<li>节流函数。</li>
</ol>
]]></summary>
        <content type="html"><![CDATA[<p>目前可以想到的方案有两种：</p>
<ol>
<li>通过变量进行控制；</li>
<li>节流函数。</li>
</ol>
<!-- more -->
<h2 id="解决方案">解决方案</h2>
<h3 id="方案一通过变量进行控制">方案一：通过变量进行控制</h3>
<p><em>book.vue</em></p>
<pre><code class="language-html">&lt;template&gt;
    &lt;view @tap=&quot;handleClickBook(bookId)&quot;&gt;点我试试看&lt;/view&gt;
&lt;/template&gt;

&lt;script&gt;
import Taro from '@taro/tarojs';
import {throttle} from '../utils/utils';

export default {
    data: {
        // 初始为可以跳转的状态
        canJump: true,
    },
    onHide() {
        this.canJump = true;
    },
    methods: {
        handleClickBook(bookId: number) {
            if (this.canJump) {
                // 当触发跳转函数的时候，需要将跳转的标志位设为false，表示在跳转完成之前，不能重复进行操作
                this.canJump = false;
                Taro.navigateTo({
                    url: '/pages/detail/index' + bookId
                });
            }
        },
    }
};
&lt;/script&gt;
</code></pre>
<p>这种方式是满足我们的需求的，但却不是最好的方案，更好的方案是使用 ** 节流函数** 。为什么说它更好呢？我们接着往下看👇</p>
<h3 id="方案二节流函数推荐">方案二：节流函数（推荐）</h3>
<p>首先来看一看如何来编写我们的节流函数，这里给出一个示例，这个示例中的节流方法有两种：</p>
<ol>
<li>时间戳；</li>
<li>setTimeout。</li>
</ol>
<p><em>utils/utils.js</em></p>
<pre><code class="language-js">/**
 * @desc 函数节流
 * @param func 函数
 * @param wait 延迟执行毫秒数
 * @param type 1 表时间戳版，2 表定时器版
 */
export function throttle(func, wait, type = 1) {
    let previous = 0;
    let timeout: null | NodeJS.Timeout = null;
    if (type === 1) {
        previous = 0;
    }
    else if (type === 2) {
        timeout = null;
    }
    return function () {
        const context = this;
        const args = arguments;
        if (type === 1) {
            const now = Date.now();

            if (now - previous &gt; wait) {
                func.apply(context, args);
                previous = now;
            }
        }
        else if (type === 2) {
            if (!timeout) {
                timeout = setTimeout(() =&gt; {
                    timeout = null;
                    func.apply(context, args);
                }, wait);
            }
        }
    };
}
</code></pre>
<p>好了，已经变写好了我们的节流函数，接下来看看如何去应用它：</p>
<p><em>book.vue</em></p>
<pre><code class="language-html">&lt;template&gt;
    &lt;view @tap=&quot;handleClickBook(bookId)&quot;&gt;点我试试看&lt;/view&gt;
&lt;/template&gt;

&lt;script&gt;
import Taro from '@taro/tarojs';
import {throttle} from '../utils/utils';

export default {
    data: {
        bookId: 1,
    },
    methods: {
        handleClickBook: throttle(function nav(bookId: number) {
            Taro.navigateTo({
                url: '/pages/detail/index' + bookId
            })
        }, 1500),
    }
};
&lt;/script&gt;
</code></pre>
<p>🙆‍♂️OK，这样我们就解决了我们遇到的重复跳转的问题啦！</p>
<p>❓那为什么我更推荐使用节流函数的方案呢？是因为节流函数的方案更便于将跳转api封装成工具方法，避免在所有涉及到跳转的地方都需要做一次防止重复点击的处理。</p>
<p>👁那我们又该如何将跳转api封装成工具方法？如何去使用被封装的工具方法呢？</p>
<p><em>util/index.js</em>：封装跳转api</p>
<pre><code class="language-js">import Taro from '@taro/tarojs';
import {throttle} from '../utils/utils';

export const navigateTo = throttle(function nav(bookId: number): void {
    Taro.navigateTo({
        url: '/pages/detail/index' + bookId
    })
}, 1500);
</code></pre>
<p><em>book.vue</em></p>
<pre><code class="language-html">&lt;template&gt;
    &lt;view @tap=&quot;handleClickBook(bookId)&quot;&gt;点我试试看&lt;/view&gt;
&lt;/template&gt;

&lt;script&gt;
import Taro from '@taro/tarojs';
import {throttle} from '../utils/utils';
import {navigateTo} from '../utils/index';

export default {
    data: {
        bookId: 1,
    },
    methods: {
        // 只需要调用一下封装好的api就好了
        handleClickBook() {
            navigateTo(bookId);
        },
    }
};
&lt;/script&gt;
</code></pre>
<p>👀你看，这样是不是更简单了，仅仅需要在一个地方做防止重复跳转的逻辑就好了！</p>
<p><em><font color="gray">以下为我的踩坑记录，不用看。</font></em></p>
<h2 id="踩坑">踩坑</h2>
<p>在开发过程中，我在以上两种方案上都踩过坑。</p>
<p><strong>方案一踩的坑</strong></p>
<p>我曾在 <code>Taro.navigate</code> 的 <code>success</code> 回调中去复原 <code>canump</code> 的值，但是发现根本没有解决问题。原因在于 <code>Taro.navigate</code> 的 <code>success</code> 回调并不是在跳转完成之后执行的，而是在程序确认改路径可以跳转后就已经执行，但是在那个时候，页面还处于存在的状态。一旦<code>canump</code> 的值被复原，那么用户又可以重复点击重复跳转了。</p>
<p><strong>方案二踩的坑</strong></p>
<p>这个坑踩在封装跳转函数的时候，先看踩坑的代码：</p>
<pre><code class="language-js">import Taro from '@taro/tarojs';
import {throttle} from '../utils/utils';

export const navigateTo = (bookId): void =&gt; throttle(function nav() {
    Taro.navigateTo({
        url: '/pages/detail/index' + bookId
    })
}, 1500);
</code></pre>
<p>拿这里的代码跟上面可用的工具方法对比一下就知道问题出在哪里了：我将 <code>throttle</code> 外面又包装了一个函数，这样的话 <code>throttle</code> 函数就没有起到它应有的作用。因为每次 <code>navigateTo</code> 执行的都是一个新函数。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链式调用实现原理]]></title>
        <id>https://awhitemouse.github.io/post/lian-shi-diao-yong-shi-xian-yuan-li/</id>
        <link href="https://awhitemouse.github.io/post/lian-shi-diao-yong-shi-xian-yuan-li/">
        </link>
        <updated>2021-01-06T03:01:03.000Z</updated>
        <summary type="html"><![CDATA[<p>中心思想是在函数的结尾 <code>return this;</code> .</p>
]]></summary>
        <content type="html"><![CDATA[<p>中心思想是在函数的结尾 <code>return this;</code> .</p>
<!-- more -->
<p>场景：实现一个可以实现简单的加减乘除的类，可以通过链式调用的方式进行加减乘除，最终返回最后的结果。</p>
<h2 id="基础版">基础版</h2>
<pre><code class="language-js">class MyMath {
    constructor(num) {
        this.num = num;
    }

    add(num) {
        this.num += num;
        return this;
    }

    sub(num) {
        this.num -= num;
        return this;
    }

    mul(num) {
        this.num *= num;
        return this;
    }

    div(num) {
        this.num /= num;
        return this;
    }
}

const result = new MyMath(2).add(5).mul(2).sub(7);
console.log(result);   // {num: 7}
</code></pre>
<p>在上面的demo中，我们可以通过 <code>return this;</code> 来完成链式调用。</p>
<p>但是上面的demo有一点缺陷，因为最终返回的还不是我们的想要的结果，所以还需要添加一个用于导出最后结果的方法。</p>
<h2 id="加强版">加强版</h2>
<p>这里我添加了一个 <code>run</code> 方法，用于导出最后的结果。</p>
<pre><code class="language-js">class MyMath {
    constructor(num) {
        this.num = num;
    }

    add(num) {
        this.num += num;
        return this;
    }

    sub(num) {
        this.num -= num;
        return this;
    }

    mul(num) {
        this.num *= num;
        return this;
    }

    div(num) {
        this.num /= num;
        return this;
    }

    run() {
        return this.num;
    }
}

const result = new MyMath(2).add(5).mul(2).sub(7).run();
console.log(result);  // 7
</code></pre>
<h2 id="我是尾巴">我是尾巴</h2>
<p>在实际业务场景中，链式调用常见于 <code>Promise</code> 。那么想象一下， <code>Promise</code> 的链式调用是如何实现的呢？</p>
]]></content>
    </entry>
</feed>