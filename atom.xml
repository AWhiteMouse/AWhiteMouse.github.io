<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://awhitemouse.github.io/</id>
    <title>白山</title>
    <updated>2021-06-29T09:48:25.107Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://awhitemouse.github.io/"/>
    <link rel="self" href="https://awhitemouse.github.io/atom.xml"/>
    <subtitle>温故而知新。</subtitle>
    <logo>https://awhitemouse.github.io/images/avatar.png</logo>
    <icon>https://awhitemouse.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 白山</rights>
    <entry>
        <title type="html"><![CDATA[实现 stylus 预处理器的 css module]]></title>
        <id>https://awhitemouse.github.io/post/shi-xian-stylus-yu-chu-li-qi-de-css-module/</id>
        <link href="https://awhitemouse.github.io/post/shi-xian-stylus-yu-chu-li-qi-de-css-module/">
        </link>
        <updated>2021-06-28T06:20:42.000Z</updated>
        <summary type="html"><![CDATA[<p>新接手了一个后台CMS项目，项目的技术栈是React，内容的展示方式是多页签的方式，也就是存在多个模块共存的情况。</p>
<p>在熟悉项目代码的时候，发现项目的原始开发者居然利用这个条件，让多个模块共用某一个模块的样式，这样无序的样式使用方法，很容易造成一些问题。比如：样式覆盖、样式丢失等。</p>
]]></summary>
        <content type="html"><![CDATA[<p>新接手了一个后台CMS项目，项目的技术栈是React，内容的展示方式是多页签的方式，也就是存在多个模块共存的情况。</p>
<p>在熟悉项目代码的时候，发现项目的原始开发者居然利用这个条件，让多个模块共用某一个模块的样式，这样无序的样式使用方法，很容易造成一些问题。比如：样式覆盖、样式丢失等。</p>
<!-- more -->
<p>所以我决定引入css module来解决模块间样式相互依赖的问题。</p>
<h2 id="相关技术栈">相关技术栈</h2>
<p>项目是使用 <code>react-app-rewired</code> 搭建的，具体使用方法参考 <code>参考链接[1]</code>. 项目使用的css预处理器是 stylus。</p>
<h2 id="代码改造">代码改造</h2>
<p>为了更加突出重点，也为了保护项目隐私，所以后面只会展示部分相关的原始代码。</p>
<p>由于项目是使用 <code>react-app-rewired</code> 搭建的，使用 <code>react-app-rewired</code> 的用处在于可以在不弹出脚手架默认webpack配置的情况下，对默认 webpack 配置内容进行覆盖和改写。</p>
<p>原始 <code>config-overrides.js</code> 文件的代码是这样的：</p>
<p><strong>config-overrides.js</strong></p>
<pre><code class="language-js">// @Description: 结合react-app-rewired个性化处理CRA中的webpack配置(因为CRA中关于webpack的处理封装到了react-script中,不想做eject处理)
/* eslint-disable */
const path = require('path');
const {
    override, fixBabelImports, addLessLoader,
    disableEsLint, addWebpackResolve
} = require('customize-cra');
const MiniCssExtractPlugin = require('mini-css-extract-plugin');

//  支持stylus
const stylus = () =&gt; config =&gt; {
    const finialLoader = config.mode === 'development' ? 'style-loader' : MiniCssExtractPlugin.loader;
    const stylusLoader = {
        test: /\.styl$/,
        use: [
            {
                loader: finialLoader
            }, {
                loader: 'css-loader',
            }, {
                loader: 'stylus-loader',
            }
        ]
    };
    const {oneOf} = config.module.rules.find(rule =&gt; rule.oneOf);
    oneOf.unshift(stylusLoader);
    return config;
};

const rewiredMap = () =&gt; config =&gt; {
    config.devtool = config.mode === 'development' ? 'cheap-module-source-map' : false;
    return config;
};

module.exports = {
    // The Webpack config to use when compiling your react app for development or production.
    webpack: override(
        // 关闭mapSource
        rewiredMap(),
        disableEsLint(),
        fixBabelImports('import', {
            libraryName: 'antd',
            libraryDirectory: 'es',
            // style: 'css',
            style: true,
        }),
        addLessLoader({
            lessOptions: {
                javascriptEnabled: true,
                // modifyVars: { '@primary-color': '#1DA57A' },
            }
        }),
        stylus(),
        addWebpackResolve({
            alias: {
                '@resource': path.resolve(__dirname, 'src/resource'),
                '@common': path.resolve(__dirname, 'src/common'),
                '@module': path.resolve(__dirname, 'src/module'),
                '@icomoon': path.resolve(__dirname, 'src/icomoon'),
                '@service': path.resolve(__dirname, 'src/service'),
            }
        })
    ),
    // ……
};
</code></pre>
<p>从代码里可以看到关于 stylus 的处理被放在了 <code>stylus</code> 方法中，目前实现的功能是能够解析 <code>.styl</code> 后缀的样式文件。</p>
<p>而我所需要做的是让 <code>*.styl</code> 支持css module，所以只需要修改 <code>stylus</code> 方法就行。</p>
<p>实现 css module 的代码如下：</p>
<pre><code class="language-js">//  支持stylus
const stylus = () =&gt; config =&gt; {
    const finialLoader = config.mode === 'development' ? 'style-loader' : MiniCssExtractPlugin.loader;
    const stylusLoader = {
        test: /\.styl$/,
        // 剔除 .module.styl 文件
        exclude: /\.module.styl$/,
        use: [
            {
                loader: finialLoader
            }, {
                loader: 'css-loader',
            }, {
                loader: 'stylus-loader',
            }
        ]
    };
    const stylusModuleLoader = {
        // 仅对 .module.styl 文件进行处理
        test: /\.module.styl$/,
        use: [
            {
                loader: finialLoader
            }, {
                loader: 'css-loader',
                // ！！！Important！！！
                options:{
                    modules: true,
                }
            }, {
                loader: 'stylus-loader',
            }
        ]
    };
    const {oneOf} = config.module.rules.find(rule =&gt; rule.oneOf);
    oneOf.unshift(stylusLoader, stylusModuleLoader);
    return config;
};
</code></pre>
<p>这样改完就实现了 css module 了。</p>
<h2 id="使用验证">使用验证</h2>
<p>为了验证 css module 确实生效了，我得做一个测试。测试方式如下：</p>
<p>选择某个模块的 <code>index.styl</code>文件，将文件名改成 <code>index.module.styl</code> 。</p>
<pre><code class="language-diff">-index.styl
+index.module.styl
</code></pre>
<p>接着改一下该模块引入样式文件的方式：</p>
<p><strong>index.tsx</strong></p>
<pre><code class="language-diff">-import './index.styl';
+import styles from './index.module.styl';
</code></pre>
<p>这样改是因为我们使用css module的时候是会给元素的class属性赋值一个类名变量，而不是一个字符串，就像下面这样：</p>
<p><strong>index.tsx</strong></p>
<pre><code class="language-diff">-import './index.styl';
+import styles from './index.module.styl';

-&lt;div className=&quot;task-filter&quot;&gt;&lt;/div&gt;
+&lt;div className={styles[&quot;task-filter&quot;]}&gt;&lt;/div&gt;
</code></pre>
<p>修改完之后重启项目，在浏览器控制台中可以看见该元素的类名变成了下面这样👇</p>
<figure data-type="image" tabindex="1"><img src="https://awhitemouse.github.io//post-images/1624870986141.jpg" alt="" loading="lazy"></figure>
<pre><code class="language-html">&lt;div class=&quot;_1eNJZCuG-X4NKKwr3f_ZC6&quot;&gt;&lt;/div&gt;
</code></pre>
<p>这说明css module已经生效了。而我们常见的css module的类名并不是这种随机的字符串，而是一些特定名称的拼接组合。如果要实现这种拼接组合该怎么做呢？其实也很简单，只需要找到 <code>stylus</code> 方法里 <code>stylusModuleLoader</code> 对象里的 <code>modules</code> 属性值即可：</p>
<pre><code class="language-diff">-modules: true
+modules: {
+    localIdentName: &quot;[path][name]__[local]--[hash:5]&quot;
+}
</code></pre>
<p><code>stylusModuleLoader</code> 修改后代码如下：</p>
<pre><code class="language-js">// 自定义模块化名称
const stylusModuleLoader = {
    test: /\.module.styl$/,
    use: [
        {
            loader: finialLoader
        }, {
            loader: 'css-loader',
            options: {
                modules: {
                    localIdentName: &quot;[path][name]__[local]--[hash:5]&quot;
                },
            }
        }, {
            loader: 'stylus-loader',
        }
    ]
};
</code></pre>
<p>当我们完成了类名的自定义之后，可以在浏览器控制台中看到如下的类名展示：</p>
<pre><code class="language-html">&lt;div class=&quot;src-module-TaskPoint-index-module__task-filter--86d9f&quot;&gt;&lt;/div&gt;
</code></pre>
<p>关于<code>[path]</code>、<code>[name]</code>、<code>[local]</code>、<code>[hash]</code>的含义参考<code>参考链接[3]</code>。</p>
<h2 id="问题处理">问题处理</h2>
<p>当然我在完成这次改动的过程中，也遇到了一些问题。当我改完之后重启项目时，项目启动失败，vscode控制台打印如下的错误</p>
<figure data-type="image" tabindex="2"><img src="https://awhitemouse.github.io//post-images/1624871764728.png" alt="" loading="lazy"></figure>
<p>经过查找资料发现是 <code>stylus-loader</code> 版本太高了，不兼容 <code>getOptions</code> 方法，当前是 <code>stylus-loader@^6.1.0</code>。于是我看着网上方法调低了版本至 <code>stylus-loader@^3.0.2</code>，然后重启项目，项目又启动失败了，控制台报错如下：</p>
<figure data-type="image" tabindex="3"><img src="https://awhitemouse.github.io//post-images/1624872036302.png" alt="" loading="lazy"></figure>
<p>而这个问题又是因为 <code>stylus-loader</code> 版本太低了，需要使用<code>~</code>来查找路径。所以我将版本调整至 <code>stylus-loader@^4.2.0</code>。此时重启项目，终于成功了！</p>
<figure data-type="image" tabindex="4"><img src="https://awhitemouse.github.io//post-images/1624872234937.png" alt="" loading="lazy"></figure>
<h2 id="参考链接">参考链接</h2>
<ol>
<li><a href="http://wmm66.com/index/article/detail/id/165.html">react-app-rewired使用</a>.</li>
<li><a href="https://github.com/SimpleRoom/react-draw">SimpleRoom/react-draw: React版老虎机~</a>.</li>
<li><a href="https://blog.csdn.net/whuhewei/article/details/105724257">使用localIdentName来自定义模块化的类名</a>.</li>
<li><a href="https://www.cnblogs.com/fsg6/p/14393185.html">TypeError: this.getOptions is not a function (安装stylus)</a>.</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React多页签]]></title>
        <id>https://awhitemouse.github.io/post/react-duo-ye-qian/</id>
        <link href="https://awhitemouse.github.io/post/react-duo-ye-qian/">
        </link>
        <updated>2021-06-22T11:28:13.000Z</updated>
        <summary type="html"><![CDATA[<p>主要讲述一下在实现React多页签过程中遇到的一些问题以及解决方案。</p>
]]></summary>
        <content type="html"><![CDATA[<p>主要讲述一下在实现React多页签过程中遇到的一些问题以及解决方案。</p>
<!-- more -->
<p>Vue 自带的 <code>keep-alive</code> 组件使得 Vue 本身就支持多页签的形式。但是 React 是不附带类似组件的，而且后续也没有添加类似功能的想法。所以我们需要自己实现一个多页签。</p>
<p>在时间有限的情况下，为了更顺利的完成这件事。必须先要将将要面临的问题给找出来，根据问题寻找答案，最后将答案汇总，才能实现最终的想要的效果。</p>
<h2 id="问题">问题</h2>
<p>要实现一个多页签系统，需要考虑这么几个问题：</p>
<ul>
<li>多个页面可以同时存在</li>
<li>从一个列表页可以打开多个详情页，每个详情页都需要拥有一个独立的页面</li>
<li>存在多个详情页时，每个详情页的标题应该不同，需要动态设置标题</li>
<li>页面可以被关闭，且当前页关闭后能切换到前一个页面</li>
<li>默认添加首页，首页不可被关闭</li>
<li>页面之间可以相互通信。比如：详情页更新了数据，列表页如果存在，则列表页需要更新数据</li>
<li>打开某个页签后刷新，被打开的页签仍需被保留</li>
<li>可以在系统里的任意一个位置触发路由跳转</li>
<li>可以直接通过修改路由url直接访问到指定页面</li>
<li>当输入了不可识别的url时，需要重定向到404页或者首页</li>
<li>给列表页添加了参数导致出现两个列表页：如何防止由于手动给列表页或者其他不应该带参数的路径添加路径，导致出现两个列表页的情况</li>
<li>……</li>
</ul>
<h2 id="解决方案">解决方案</h2>
<p>首先有一个大方向，想要做成多页签，那么切换路由的时候必然是不伴随页面刷新的。所以可以确定一个大致的方向是使用 <code>HashRouter</code>。</p>
<p><strong>多个页面可以同时存在</strong></p>
<p>目前网上统一口风，都是使用antd的Tabs组件实现，而我们需要展示的多个页面在Tabs看来就是多个组件。</p>
<p><strong>从一个列表页可以打开多个详情页，每个详情页都需要拥有一个独立的页面</strong></p>
<p>Tabs组件会使用唯一key对应唯一组件的方式实现面板的渲染和切换，而多个详情页实际上使用的是同一个模板。为了达到详情页之间互相隔离的效果，不同的详情页就必须要使用不同的key值。此时就需要页面本身的key加上页面的params，两者组合生成唯一key。</p>
<p><strong>存在多个详情页时，每个详情页的标题应该不同，需要动态设置标题</strong></p>
<p>全局提供一个 setTitle 方法，调用时可更改当前页签的标题。</p>
<p><strong>页面可以被关闭，且当前页关闭后能切换到前一个页面</strong></p>
<p>Tabs组件本身是支持关闭页签的，而我们要做的就是在关闭页签之前，先切换一下活跃的tab key值就好了。</p>
<p><strong>默认添加首页，首页不可被关闭</strong></p>
<p>初始时默认向面板列表里插入一项数据。</p>
<p><strong>页面之间可以相互通信</strong></p>
<p>使用发布订阅（trigger + on）的方式来实现页面的相互通信。</p>
<p><strong>打开某个页签后刷新，被打开的页签仍需被保留</strong></p>
<p>其实实现的思路并不是保留，而是通过识别hash然后向面板列表插入hash对应的数据。</p>
<p><strong>可以在系统里的任意一个位置触发路由跳转</strong></p>
<p>可以使用 react-router-dom 提供 history.push 或者 history.replace 方法进行hash的切换。</p>
<p><strong>可以直接通过修改路由url直接访问到指定页面</strong></p>
<p>同<em>打开某个页签后刷新，被打开的页签仍需被保留</em>。</p>
<p><strong>当输入了不可识别的url时，需要重定向到404页或者首页</strong></p>
<p>在识别了hash值之后，先不急着向面板列表里插入数据，而是先判断hash值是否正确，是否可用（系统中是否存在该hash路由）。如果发现hash是不可用的，则需要 replace 方法更新hash值为首页或者404页的路径。</p>
<p><strong>给列表页添加了参数导致出现两个列表页</strong></p>
<p>正常来说，列表页应该是不携带参数的，同一个列表页不会被渲染多次。但是由于存在 key + params 生成唯一key的机制，所以可能会将带参数的列表页误识别为另一个页。</p>
<p>此时需要在配置里添加 exact 属性，用于标识当前页是否允许存在参数，当发现不应该携带了参数的路径携带了参数时，使用replace重定向到不带params的路径上。</p>
<h2 id="参考">参考</h2>
<p><strong>参考文章</strong></p>
<ol>
<li><a href="https://blog.csdn.net/It_rod/article/details/109132601">react多页签页面缓存</a>.</li>
</ol>
<p><strong>参考项目</strong></p>
<ol>
<li><a href="https://github.com/rodchen-king/ant-design-pro-v2">rodchen-king/ant-design-pro-v2</a>.</li>
<li><a href="https://github.com/hsl947/react-antd-multi-tabs-admin">hsl947/react-antd-multi-tabs-admin</a>.</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[display: none、visibility: hidden与opacity: 0的区别]]></title>
        <id>https://awhitemouse.github.io/post/display-nonevisibility-hidden-yu-opacity-0-de-qu-bie/</id>
        <link href="https://awhitemouse.github.io/post/display-nonevisibility-hidden-yu-opacity-0-de-qu-bie/">
        </link>
        <updated>2021-06-21T10:47:07.000Z</updated>
        <summary type="html"><![CDATA[<p><code>display: none</code>、<code>visibility: hidden</code> 与 <code>opacity: 0</code> 是我们常用来隐藏元素的几种方法，那么它们之间有什么区别呢？</p>
]]></summary>
        <content type="html"><![CDATA[<p><code>display: none</code>、<code>visibility: hidden</code> 与 <code>opacity: 0</code> 是我们常用来隐藏元素的几种方法，那么它们之间有什么区别呢？</p>
<!-- more -->
<h2 id="区别">区别</h2>
<ol>
<li>设置了 <code>display: none</code> 的元素不会被渲染在页面中，不影响页面其他元素的布局；而设置了<code>visibility: hidden</code> 和 <code>opacity: 0</code> 的元素虽然在页面中不可见，但是它们仍然会被渲染，在页面中占据着相应的位置。</li>
<li>由于 <code>display: none</code> 会影响布局，所以它会引起 <code>回流</code> 和 <code>重绘</code> ；而<code>visibility: hidden</code> 和 <code>opacity: 0</code> 不会影响页面布局，所以它只会引起 <code>重绘</code> 。</li>
<li><code>visibility: hidden</code> 具有继承性，但其子元素如果设置了 <code>visibility: visible</code>，那么子元素仍然会展示； <code>opacity: 0</code> 也具有继承性，即使子元素设置了 <code>opacity: 1</code>，子元素仍不可见。</li>
<li><code>visibility: hidden</code> 隐藏元素后元素不可点击，但是如果其子元素如果设置了 <code>visibility: visible</code>，那么其子元素仍可被点击；设置了 <code>opacity: 0</code> 的元素，元素本身及其子元素都可以被点击。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Antd Form表单设置validateFields校验无飘红提示]]></title>
        <id>https://awhitemouse.github.io/post/antd-form-biao-dan-she-zhi-validatefields-xiao-yan-wu-piao-hong-ti-shi/</id>
        <link href="https://awhitemouse.github.io/post/antd-form-biao-dan-she-zhi-validatefields-xiao-yan-wu-piao-hong-ti-shi/">
        </link>
        <updated>2021-06-10T02:48:06.000Z</updated>
        <summary type="html"><![CDATA[<p>使用 <code>validateFields</code>，点击保存的时候控制台会打印警告，但是表单中无飘红提示。</p>
]]></summary>
        <content type="html"><![CDATA[<p>使用 <code>validateFields</code>，点击保存的时候控制台会打印警告，但是表单中无飘红提示。</p>
<!-- more -->
<h2 id="问题背景">问题背景</h2>
<p>写了一个表单校验，用来验证输入的字符串是否全为空格。当我点击保存的时候（调用 <code>validateFields</code> 方法），在控制台提示了如下警告：</p>
<figure data-type="image" tabindex="1"><img src="https://awhitemouse.github.io//post-images/1623294251997.png" alt="" loading="lazy"></figure>
<p>代码是这样的：</p>
<pre><code class="language-jsx">&lt;FormItem
    label=&quot;规格&quot;
    className=&quot;contact-detail-info-form-item&quot;
    {...formItemLayout}
&gt;
    {
        getFieldDecorator('specification', {
            initialValue: data.specification,
            rules: [
                {
                    required: true,
                    message: '请输入规格',
                },
                {
                    validator: (rule, value, callback) =&gt; {
                        /* 注意看这里！！！ */
                        if (value.length &amp;&amp; !value.trim().length) {
                            callback('规格文案不能全为空格');
                        }
                        else {
                            callback();
                        }
                    }
                }
            ],
        })(&lt;Input
            allowClear
            className=&quot;custom-input&quot;
            placeholder=&quot;请输入规格&quot;
        /&gt;)
    }
&lt;/FormItem&gt;
</code></pre>
<h2 id="解决方案">解决方案</h2>
<p>通过查阅相关问题发现，只要在 <code>validator</code> 方法的判断中加上对于 <code>value</code> 值本身的判断就能解决问题。像下面这样：</p>
<pre><code class="language-jsx">&lt;FormItem
    label=&quot;规格&quot;
    className=&quot;contact-detail-info-form-item&quot;
    {...formItemLayout}
&gt;
    {
        getFieldDecorator('specification', {
            initialValue: data.specification,
            rules: [
                {
                    required: true,
                    message: '请输入规格',
                },
                {
                    validator: (rule, value, callback) =&gt; {
                        /* 注意看这里！！！加上了 value 的判断 */
                        if (value &amp;&amp; !value.trim().length) {
                            callback('规格文案不能全为空格');
                        }
                        else {
                            callback();
                        }
                    }
                }
            ],
        })(&lt;Input
            allowClear
            className=&quot;custom-input&quot;
            placeholder=&quot;请输入规格&quot;
        /&gt;)
    }
&lt;/FormItem&gt;
</code></pre>
<p>加上对于 value 的判断后再去校验就出现飘红提示了。</p>
<figure data-type="image" tabindex="2"><img src="https://awhitemouse.github.io//post-images/1623294311718.png" alt="" loading="lazy"></figure>
<h2 id="问题原因分析">问题原因分析</h2>
<p>虽然问题解决了，但是如此怪异的问题我还是得弄清楚原因才行，不然再次遇到同类问题的时候可能不知道该怎么处理。</p>
<p>对比了一下前后的区别，发现将 <code>value.length</code> 改成 <code>value</code> 的区别在于 <code>value.length</code> 这个表达式本身就可能报错。比如当 <code>value</code> 为 <code>undefined</code> 时。</p>
<p>而 <code>validator</code> 非常强调的一件事就是 <code>callback</code> 方法必须要被执行。而当 <code>value</code> 为 <code>undefined</code> 时，程序在运行时就会报错，导致 <code>callback</code> 方法没有被调用。</p>
<p>而程序报错没有却没有在控制台看到错误打印的原因是可能是因为 Antd Form validator 外部使用了 <code>try...catch</code> 对错误进行捕获。</p>
<h3 id="实践出真知">实践出真知。</h3>
<p>为了验证这个猜想的正确性，我在代码代码中添加了如下的打印：</p>
<pre><code class="language-js">// 校验空格
const validateBlank = (rule: any, value: string, callback: (str?: string) =&gt; void) =&gt; {
    console.log(1);
    if (value.length &amp;&amp; !value.trim().length) {
        console.log(2);
        callback('规格文案不能全为空格');
    }
    else {
        console.log(3);
        callback();
    }
};
</code></pre>
<p>然后点击保存。发现在控制台中仅仅打印了 <code>1</code>。这样的验证结果是符合我的猜想的。为了更加坚定这个结论，我查阅了 Antd 文档。</p>
<h3 id="知子莫如父">知子莫如父。</h3>
<p>我在 Antd 文档中发现了这样一个FAQ：<a href="https://ant.design/components/form-cn/#%E8%87%AA%E5%AE%9A%E4%B9%89-validator-%E6%B2%A1%E6%9C%89%E6%95%88%E6%9E%9C">自定义 validator 没有效果</a>.</p>
<p>描述如下：</p>
<blockquote>
<p>这是由于你的 <code>validator</code> 有错误导致 <code>callback</code> 没有执行到。你可以选择通过 <code>async</code> 返回一个 promise 或者使用 <code>try...catch</code> 进行错误捕获：</p>
</blockquote>
<p>这段描述的第一句话就正中下怀啊。官方提供的解决方案是在 <code>validator</code> 方法内部使用 <code>try...catch</code> 进行错误捕获，然后在 <code>catch</code> 语句中调用一下 <code>callback</code>。详情参见上方的文档。</p>
<h2 id="参考链接">参考链接</h2>
<ol>
<li><a href="https://blog.csdn.net/weixin_30698775/article/details/112592844">控制台输入框_antdvue:form表单提交时,只在控制台输出error,输入框不标红 底下也没提示...</a>.</li>
</ol>
<h2 id="拓展">拓展</h2>
<ol>
<li><a href="https://juejin.cn/post/6844903935728189447">antd-Form表单设置validateFields校验无飘红提示</a>.</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何处理按钮组边框线问题]]></title>
        <id>https://awhitemouse.github.io/post/ru-he-chu-li-an-niu-zu-bian-kuang-xian-de-wen-ti/</id>
        <link href="https://awhitemouse.github.io/post/ru-he-chu-li-an-niu-zu-bian-kuang-xian-de-wen-ti/">
        </link>
        <updated>2021-06-09T07:31:39.000Z</updated>
        <summary type="html"><![CDATA[<p>关键点在于如何处理相邻元素的边框线。</p>
]]></summary>
        <content type="html"><![CDATA[<p>关键点在于如何处理相邻元素的边框线。</p>
<!-- more -->
<h2 id="基本用法">基本用法</h2>
<p>最常见的用法是使用css的 <code>元素选择器</code>，代码示例如下：</p>
<p class="codepen" data-height="265" data-theme-id="dark" data-default-tab="html,result" data-user="awhitemouse" data-slug-hash="yLMqEeG" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="元素选择器消除相邻元素边框线">
  <span>See the Pen <a href="https://codepen.io/awhitemouse/pen/yLMqEeG">
  元素选择器消除相邻元素边框线</a> by chenxin (<a href="https://codepen.io/awhitemouse">@awhitemouse</a>)
  on <a href="https://codepen.io">CodePen</a>.</span>
</p>
<p>这种方法对付一般性的需求是没有问题的，但是如果遇到了比较特殊的情况就出问题了，比如这样：</p>
<figure data-type="image" tabindex="1"><img src="https://awhitemouse.github.io//post-images/1623224766667.png" alt="" loading="lazy"></figure>
<p>因为换行的原因导致中间元素没有右边框的问题被暴露出来了。</p>
<h2 id="margin-right负值">margin-right负值</h2>
<p>为了解决换行导致的样式问题，需要保证每个元素的左右边框都存在。</p>
<p>那么问题转换成了如何将两个元素的相邻边框压缩成1个边框。</p>
<p>☝️一个很好的办法就是使用 margin-right 负值。代码示例如下：</p>
<p class="codepen" data-height="265" data-theme-id="dark" data-default-tab="html,result" data-user="awhitemouse" data-slug-hash="LYWBrpG" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="margin-right负值解决相邻边框线的问题">
  <span>See the Pen <a href="https://codepen.io/awhitemouse/pen/LYWBrpG">
  margin-right负值解决相邻边框线的问题</a> by chenxin (<a href="https://codepen.io/awhitemouse">@awhitemouse</a>)
  on <a href="https://codepen.io">CodePen</a>.</span>
</p>
<script async src="https://cpwebassets.codepen.io/assets/embed/ei.js"></script>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【转载】探秘 flex 上下文中神奇的自动 margin]]></title>
        <id>https://awhitemouse.github.io/post/zhuan-zai-tan-mi-flex-shang-xia-wen-zhong-shen-qi-de-zi-dong-margin/</id>
        <link href="https://awhitemouse.github.io/post/zhuan-zai-tan-mi-flex-shang-xia-wen-zhong-shen-qi-de-zi-dong-margin/">
        </link>
        <updated>2021-05-31T06:19:24.000Z</updated>
        <summary type="html"><![CDATA[<p><a href="https://www.cnblogs.com/coco1s/p/10910588.html">阅读原文</a></p>
]]></summary>
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/coco1s/p/10910588.html">阅读原文</a></p>
<!-- more -->
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JS复制canvas图片到剪切板]]></title>
        <id>https://awhitemouse.github.io/post/js-fu-zhi-tu-pian-dao-jian-qie-ban/</id>
        <link href="https://awhitemouse.github.io/post/js-fu-zhi-tu-pian-dao-jian-qie-ban/">
        </link>
        <updated>2021-04-27T04:10:55.000Z</updated>
        <summary type="html"><![CDATA[<p>最近在写一个小工具，用来生成指定宽高与颜色的图片：<a href="https://hbuecx.com/GImage/">传送门</a>.我想给它添加可以一键复制图片到剪切板的功能，所以才有了这篇文章。</p>
]]></summary>
        <content type="html"><![CDATA[<p>最近在写一个小工具，用来生成指定宽高与颜色的图片：<a href="https://hbuecx.com/GImage/">传送门</a>.我想给它添加可以一键复制图片到剪切板的功能，所以才有了这篇文章。</p>
<!-- more -->
<p>作为一名前(面)端(向)高(谷)级(歌)开发人员，基本素养还是要具备的。前车之鉴，后事之师。不仅要汲取前人的经验，还需要注意避开前人踩过的坑。</p>
<p>实现类似功能的第三库包有很多，但是我只是做了一个小工具，就一个html文件而已。如果为了这么一个功能去引用一个第三方包就有点多余。所以还是决定自己写简单的函数。</p>
<p>目前相关的文章讲解关于 <code>JS复制图片到剪切板</code> 的技术方案有两种：</p>
<ul>
<li><code>document.execCommand('copy')</code></li>
<li><code>navigator.clipboard.write()</code></li>
</ul>
<p>但是 <code>document.execCommand('copy')</code> 在部分场景下会失效，秉持着高(偷)效(懒)得原则，果断选择了 <code>navigator.clipboard.write()</code> 的方案来实现图片复制。</p>
<h2 id="源码">源码</h2>
<pre><code class="language-js">// 复制图片到剪切板
function clipboard() {
    navigator.permissions.query({ name: 'clipboard-write' }).then(result =&gt; {
        if (result.state === 'granted') {
            var imageType = getImageType();
            canvas.toBlob(function deal(blob) {
                var clipboardItem = new ClipboardItem({[`image/${suffix}`]: blob});
                navigator.clipboard.write([clipboardItem]).then(() =&gt; {
                    alert('复制成功');
                });
            }, imageType);
        }
    });
}
</code></pre>
<h2 id="参考">参考</h2>
<ol>
<li><a href="https://www.jianshu.com/p/eab9bab4d5b5">记js复制图片到剪贴板的坑</a>.</li>
<li><a href="https://www.canvasapi.cn/HTMLCanvasElement/toBlob">canvas API中文网 - 中文文档 - HTMLCanvasElement.toBlob()</a>.</li>
<li><a href="https://stackoverflow.com/questions/63561767/typeerror-failed-to-construct-clipboarditem-failed-to-convert-value-to-blob?newreg=6aa69267fb374f27aade256acaa0cfaf">javascript - TypeError: Failed to construct 'ClipboardItem': Failed to convert value to 'Blob' - Stack Overflow</a>.</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[还在用 npm install ? 试试 npm ci 吧！]]></title>
        <id>https://awhitemouse.github.io/post/ni-zhi-dao-npm-ci-ma/</id>
        <link href="https://awhitemouse.github.io/post/ni-zhi-dao-npm-ci-ma/">
        </link>
        <updated>2021-04-22T03:19:57.000Z</updated>
        <summary type="html"><![CDATA[<p>在有 <code>package-lock</code> 的项目，我们可以使用 <code>npm ci</code> 来替代 <code>npm install</code>.</p>
]]></summary>
        <content type="html"><![CDATA[<p>在有 <code>package-lock</code> 的项目，我们可以使用 <code>npm ci</code> 来替代 <code>npm install</code>.</p>
<!-- more -->
<h2 id="前言">前言</h2>
<p>在阅读本文之前，你应该先了解以下知识（点击链接可以快速了解相关知识）：</p>
<ul>
<li><a href="http://www.conardli.top/blog/article/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89npm%E5%8C%85%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%EF%BC%9F.html#%E5%AE%9A%E6%9C%9F%E6%9B%B4%E6%96%B0%E4%BE%9D%E8%B5%96">npm 依赖版本管理</a></li>
<li><a href="https://docs.taro.zone/docs/README">你至少应该知道Taro是什么</a>.</li>
</ul>
<h2 id="为什么使用-npm-ci">为什么使用 npm ci</h2>
<p>最近出现了Jenkins构建成功，但是项目却运行失败的情况，排查问题的时候发现是Jenkins构建时安装依赖的版本不对导致的构建失败。</p>
<p>本身这种情况发生的概率比较小，因为我们在安装依赖的时候默认都会在依赖的版本号前面加上 <code>^</code> 来限制安装依赖的大版本。</p>
<p>这次的问题是在安装 <code>Taro</code> 时版本的不对齐导致的。如果我们需要使用 <code>Taro</code> ，除了安装 <code>@tarojs/cli</code> 之外，我们还需要安装一些依赖（使用 <code>Taro CLI</code> 创建项目时会自动安装），比如：<code>@tarojs/components</code>、 <code>@tarojs/runtime</code>、 <code>@tarojs/taro</code>等等。</p>
<p><code>Taro</code> 要求我们在安装这些依赖的时候 <code>Taro CLI</code> 版本与项目中 <code>Taro</code> 相关依赖的版本保持一致，否则无法正常运行。关于这项规则的详情可以查阅<a href="https://nervjs.github.io/taro/blog/2020-09-01-taro-versions/#%E5%B0%86-taro-cli-%E7%89%88%E6%9C%AC%E4%B8%8E%E9%A1%B9%E7%9B%AE%E4%B8%AD-taro-%E7%9B%B8%E5%85%B3%E4%BE%9D%E8%B5%96%E7%9A%84%E7%89%88%E6%9C%AC%E4%BF%9D%E6%8C%81%E4%B8%80%E8%87%B4">Taro 官方文档</a>.</p>
<p>在我们的 <code>package.json</code> 中，我们只是使用了 <code>^</code> 来限制这些依赖的大版本更新，这样的限制对于 <code>Taro</code> 来说是不足够的。</p>
<p>原本我们的方案是去掉 <code>Taro</code> 相关依赖的前面的 <code>^</code>，这样这些依赖的版本就完全固定了，除非我们手动修改它，这样的方案当然是没有问题的。</p>
<p>但除此之外，我们应该还有另一个方案。别忘了，我们在本地运行和调试项目的时候是完全正常的，也就是说我们本地安装的依赖是没问题的。</p>
<p>所以另一个方案就是让 Jenkins 构建时安装和使用与我们本地相同的依赖，如果你说直接将 <code>node_modules</code> 推送到代码仓库中，这当然也能解决问题。但我不敢保证，你的同事听到你的这番言论会不会臭骂你两句，然后踹你一脚。</p>
<p>此时我们应该想到另一个可能被我们遗忘的小机灵鬼：<code>package-lock.json</code>。这可是控制 <code>node_modules</code> 文件夹中所有依赖的源头啊。</p>
<p>是的，我们完全可以通过锁定问题的源头来解决问题，即锁定 <code>package-lock.json</code>，让 Jenkins 在构建安装依赖时使用和我们本地依赖一致的包，这样我们的问题就可以解决了。</p>
<p>而实现这一目标的的一个优雅工具就是：<code>npm ci</code>.我们可以使用 <code>npm ci</code> 取代 <code>npm install</code>，就像图里所演示的这样，将构建脚本里的 <code>npm install</code> 换成 <code>npm ci</code>，这样就可以实现我们所需要的效果了：</p>
<figure data-type="image" tabindex="1"><img src="https://awhitemouse.github.io//post-images/1619501381269.png" alt="" loading="lazy"></figure>
<p>关于使用 <code>npm ci</code> 的场景，它应该是这样的：</p>
<blockquote>
<p>在有 <code>package-lock</code> 的项目，我们可以使用 <code>npm ci</code> 来替代 <code>npm install</code>.</p>
</blockquote>
<h2 id="npm-ci-vs-npm-install">npm ci vs npm install</h2>
<p>至于 <code>npm ci</code> 相较于 <code>npm install</code> 还有哪些区别与优势，可以参考这篇文章：<a href="https://blog.csdn.net/csdn_yudong/article/details/84929546">npm ci 命令</a>.这篇文章已经清晰地讲述了它们之间的联系。</p>
<h2 id="我是尾巴">我是尾巴</h2>
<p>当我写完这篇文章的时候，心里突然感觉非常的舒畅。这像是20世纪50年代里，在那个还只有黑白电影的年代，一位瘦高的英国绅士正站在剧幕正中的讲演台上侃侃而谈。</p>
<h2 id="参考链接">参考链接</h2>
<ol>
<li><a href="https://blog.csdn.net/csdn_yudong/article/details/84929546">npm ci 命令</a>.</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[css扩大元素的点击范围]]></title>
        <id>https://awhitemouse.github.io/post/css-kuo-da-yuan-su-de-dian-ji-fan-wei/</id>
        <link href="https://awhitemouse.github.io/post/css-kuo-da-yuan-su-de-dian-ji-fan-wei/">
        </link>
        <updated>2021-04-19T11:45:35.000Z</updated>
        <summary type="html"><![CDATA[<p>QA反映有个按钮有点难点到，但是UI稿设计的宽高就这么大啊，所以只能想办法在不改变元素展示样式的情况下扩大元素的点击范围。</p>
]]></summary>
        <content type="html"><![CDATA[<p>QA反映有个按钮有点难点到，但是UI稿设计的宽高就这么大啊，所以只能想办法在不改变元素展示样式的情况下扩大元素的点击范围。</p>
<!-- more -->
<p>有两种方案都可以实现我现在的需求，它们分别是：</p>
<ul>
<li>border + background</li>
<li>伪元素</li>
</ul>
<h2 id="方案一border-background-clip">方案一：border + background-clip</h2>
<p><code>background-clip</code>：设置元素的背景（背景图片或颜色）是否延伸到边框、内边距盒子、内容盒子下面。</p>
<pre><code class="language-css">.target {
    border: 20px solid transparent;
    background-clip: padding-box;
}
</code></pre>
<h2 id="方案二伪元素">方案二：伪元素</h2>
<p>不改变元素的大小，扩大其元素的大小。</p>
<pre><code class="language-css">.target {
    position: relative;
}

.target::after {
    position: absolute;
    top: -10px;
    right: -10px;
    bottom: -10px;
    left: -10px;
}
</code></pre>
<h2 id="总结">总结</h2>
<p>方案一虽然在展示效果上没有改变，但确实是改变了原始元素的大小，可能会引起一些不必要的问题。所以我<code>更推荐方案二</code>。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于儿童交互产品的设计理念]]></title>
        <id>https://awhitemouse.github.io/post/guan-yu-er-tong-jiao-hu-chan-pin-de-she-ji-li-nian/</id>
        <link href="https://awhitemouse.github.io/post/guan-yu-er-tong-jiao-hu-chan-pin-de-she-ji-li-nian/">
        </link>
        <updated>2021-04-15T02:39:52.000Z</updated>
        <summary type="html"><![CDATA[<p>今天早会的时候，产品总监提出目前我们的产品还是有一部分偏向于成人化。这让我好奇：成人交互与儿童交互的区别在哪里呢？</p>
]]></summary>
        <content type="html"><![CDATA[<p>今天早会的时候，产品总监提出目前我们的产品还是有一部分偏向于成人化。这让我好奇：成人交互与儿童交互的区别在哪里呢？</p>
<!-- more -->
<p>我在查找资料的过程中，发现了一篇文章：<a href="http://www.gx-id.com/new/265.html">不同年龄阶段儿童交互产品设计理念需要加以区分利用</a>，其中对于成人与儿童交互应有的区别的做了详细的论述：</p>
<figure data-type="image" tabindex="1"><img src="https://awhitemouse.github.io//post-images/1618454763745.png" alt="" loading="lazy"></figure>
<p>另外还有一篇文章：<a href="https://zhuanlan.zhihu.com/p/130241756">儿童和成人学习英语的区别</a>，其中关于儿童英语学习路径的观点可以参考一下：</p>
<figure data-type="image" tabindex="2"><img src="https://awhitemouse.github.io//post-images/1618454933806.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何绘制一条优雅的圆弧线]]></title>
        <id>https://awhitemouse.github.io/post/ru-he-hui-zhi-yi-tiao-you-ya-de-yuan-hu-xian/</id>
        <link href="https://awhitemouse.github.io/post/ru-he-hui-zhi-yi-tiao-you-ya-de-yuan-hu-xian/">
        </link>
        <updated>2021-04-12T12:55:19.000Z</updated>
        <summary type="html"><![CDATA[<p>最近在做的一个需求里需要绘制一条优雅的圆弧线，UE问我要不要切图？？伤害性不大，侮辱性极强！</p>
]]></summary>
        <content type="html"><![CDATA[<p>最近在做的一个需求里需要绘制一条优雅的圆弧线，UE问我要不要切图？？伤害性不大，侮辱性极强！</p>
<!-- more -->
<p>UE给出的设计稿是下面这样的👇（看中间的那条白色圆弧线）</p>
<figure data-type="image" tabindex="1"><img src="https://awhitemouse.github.io//post-images/1618456618748.png" alt="" loading="lazy"></figure>
<p>跟UE对设计稿的时候，UE问我这个圆弧要不要切图？<del><em>嗯!? 这么简单的圆弧还切图，看不起谁呢？</em><del></p>
<p>👀之前也绘制过圆弧线，是使用 <a href="#%E7%94%BB%E5%A4%A7%E5%9C%86">画大圆</a> 的方式实现的。而这一次，我突然想到应该还有其他的办法也可以实现相同的效果吧。</p>
<p>于是查阅了一些资料，结合自身的经验总结了有如下几种画圆弧的方式：</p>
<ul>
<li>画大圆</li>
<li>定制border-radius</li>
<li>box-shadow</li>
<li>transform：scaleX/Y</li>
<li>svg</li>
<li>canvas</li>
<li>图片</li>
</ul>
<h2 id="画大圆">画大圆</h2>
<p>画大圆是最直接的实现方案了，也应该是很多开发者首先想到的方案之一了。</p>
<p>需要注意的地方是外部容器需要 <code>overflow: hidden</code> 用于隐藏圆形超过容器的部分。</p>
<iframe height="474" style="width: 100%;" scrolling="no" title="绘制圆弧 - 画大圆" src="https://codepen.io/awhitemouse/embed/gOgzpvX?height=265&theme-id=dark&default-tab=css,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href='https://codepen.io/awhitemouse/pen/gOgzpvX'>绘制圆弧 - 画大圆</a> by chenxin
  (<a href='https://codepen.io/awhitemouse'>@awhitemouse</a>) on <a href='https://codepen.io'>CodePen</a>.
</iframe>
<br>
<h2 id="定制border-radius">定制border-radius</h2>
<p>我们常用 <code>border-radius</code> 画圆角，或者是画一个圆形。使用方法大概是这样的：</p>
<pre><code class="language-css">.demo {
    border-radius: 4px;
    /* or */
    border-radius: 50%;
}
</code></pre>
<p>而这里的定制  <code>border-radius</code> 使用了它的一项不常用的技能：为每一个单边设置圆角。</p>
<pre><code class="language-css">.demo {
    border-radius: 0 12px 12px 0 / 0 50% 50% 0;
}
</code></pre>
<p>这里不详细描述关于定制 <code>border-radius</code> 的内容，详细了解可以参考这篇文章：<a href="https://juejin.cn/post/6844903693423214600">border-radius结合动画创建酷炫的效果</a>.</p>
<p>从下方的演示效果看，越靠近两端，边框被压缩得越细，这与我们想要的效果还是有一定差别的。</p>
<iframe height="474" style="width: 100%;" scrolling="no" title="绘制圆弧 - 定制border-radius" src="https://codepen.io/awhitemouse/embed/NWdMqNy?height=265&theme-id=dark&default-tab=css,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href='https://codepen.io/awhitemouse/pen/NWdMqNy'>绘制圆弧 - 定制border-radius</a> by chenxin
  (<a href='https://codepen.io/awhitemouse'>@awhitemouse</a>) on <a href='https://codepen.io'>CodePen</a>.
</iframe>
<br>
<h2 id="box-shadow">box-shadow</h2>
<p>关于 <code>box-shadow</code> 的方案，仔细对比下方的代码和 <a href="#%E5%AE%9A%E5%88%B6border-radius">定制border-radius</a> 的代码可以发现，其实就是将白色边框的绘制方式从 <code>border-right</code> 换成了<code>box-shadow</code>。</p>
<p>更换以后解决了 <a href="#%E5%AE%9A%E5%88%B6border-radius">定制border-radius</a> 方案中提到的边框压缩的问题，但是这个方案绘制出来的圆弧并不够圆润，并没有达到我所想要的效果。</p>
<iframe height="474" style="width: 100%;" scrolling="no" title="绘制圆弧 - box-shadow" src="https://codepen.io/awhitemouse/embed/xxgjwxR?height=265&theme-id=dark&default-tab=css,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href='https://codepen.io/awhitemouse/pen/xxgjwxR'>绘制圆弧 - box-shadow</a> by chenxin
  (<a href='https://codepen.io/awhitemouse'>@awhitemouse</a>) on <a href='https://codepen.io'>CodePen</a>.
</iframe>
<br>
<h2 id="transformscalexy">transform：scaleX/Y</h2>
<p>这个方案还挺有趣的，通过旋转的方式从视觉效果上改变了圆角的大小。</p>
<p>但是我简单写了一个demo之后就发现，这个方案的产生的问题跟 <a href="#%E5%AE%9A%E5%88%B6border-radius">定制border-radius</a> 方案产生的问题相同。</p>
<iframe height="265" style="width: 100%;" scrolling="no" title="绘制圆弧 - transfrom" src="https://codepen.io/awhitemouse/embed/vYgjxjB?height=265&theme-id=dark&default-tab=css,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href='https://codepen.io/awhitemouse/pen/vYgjxjB'>绘制圆弧 - transfrom</a> by chenxin
  (<a href='https://codepen.io/awhitemouse'>@awhitemouse</a>) on <a href='https://codepen.io'>CodePen</a>.
</iframe>
<br>
<h2 id="svg">svg</h2>
<p>使用 <code>svg</code> 的方案无论从使用方法还是从展示效果上，跟 <a href="#%E7%94%BB%E5%A4%A7%E5%9C%86">#画大圆</a> 效果是相同的。</p>
<iframe height="474" style="width: 100%;" scrolling="no" title="绘制圆弧 - svg" src="https://codepen.io/awhitemouse/embed/VwPxpxo?height=265&theme-id=dark&default-tab=html,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href='https://codepen.io/awhitemouse/pen/VwPxpxo'>绘制圆弧 - svg</a> by chenxin
  (<a href='https://codepen.io/awhitemouse'>@awhitemouse</a>) on <a href='https://codepen.io'>CodePen</a>.
</iframe>
<br>
<h2 id="canvas">canvas</h2>
<p>而 <code>canvas</code> 的方案与 <a href="#svg">svg 方案</a> 实现方法也是类似的，同样是绘制一个大圆环，然后使用 <code>overflow: hidden</code> 隐藏掉了溢出的部分。<em>也可以只绘制需要显示的一部分圆弧，只需要调整绘制圆弧的起始角度和终止角度即可</em>。</p>
<iframe height="474" style="width: 100%;" scrolling="no" title="绘制圆弧 - canvas" src="https://codepen.io/awhitemouse/embed/BapxZPe?height=265&theme-id=dark&default-tab=js,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href='https://codepen.io/awhitemouse/pen/BapxZPe'>绘制圆弧 - canvas</a> by chenxin
  (<a href='https://codepen.io/awhitemouse'>@awhitemouse</a>) on <a href='https://codepen.io'>CodePen</a>.
</iframe>
<br>
<h2 id="总结">总结</h2>
<p>方案罗列完毕之后就该选择方案了，从实际展示效果上进行筛选的话，可以达到操作效果的是<a href="#%E7%94%BB%E5%A4%A7%E5%9C%86">画大圆</a>、<a href="#svg">svg</a>、<a href="#canvas">canvas</a>。</p>
<p>我当前这个需求所基于的场景时小程序，小程序对 <code>svg</code> 的兼容程度并不好，而 <code>canvas</code> 无论从操作难度还是性能上，跟纯css是无法相提并论的。</p>
<p>所以最终还是选择了 <a href="#%E7%94%BB%E5%A4%A7%E5%9C%86">画大圆</a> 的解决方案。<del><em>绕了一圈又回来了</em></del></p>
<h2 id="我是尾巴">我是尾巴</h2>
<p>本文一共列举了 7 中绘制圆弧的方式，如果你还有更优的方案，或者对本文提出的方案有异议，请在评论区提出，谢谢。</p>
<h2 id="参考">参考</h2>
<ol>
<li><a href="https://zhuanlan.zhihu.com/p/28142155">网页中弧线的几种实现方法</a>.</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何做一场高质量的分享]]></title>
        <id>https://awhitemouse.github.io/post/ru-he-zuo-yi-chang-gao-zhi-liang-de-fen-xiang/</id>
        <link href="https://awhitemouse.github.io/post/ru-he-zuo-yi-chang-gao-zhi-liang-de-fen-xiang/">
        </link>
        <updated>2021-04-02T03:52:08.000Z</updated>
        <summary type="html"><![CDATA[<p>最近做了两次分享，第二次分享完之后，自我感觉不是很理想。正好看到这样一篇分析高质量分享的<a href="https://mp.weixin.qq.com/s/ZcHkIs00kVeyZ2-7u3cg5A">文章</a>，看完之后确有所得，所以这里对这篇文章里提到的自己踩过坑的地方列出来，结合自己的经历做一个总结。</p>
]]></summary>
        <content type="html"><![CDATA[<p>最近做了两次分享，第二次分享完之后，自我感觉不是很理想。正好看到这样一篇分析高质量分享的<a href="https://mp.weixin.qq.com/s/ZcHkIs00kVeyZ2-7u3cg5A">文章</a>，看完之后确有所得，所以这里对这篇文章里提到的自己踩过坑的地方列出来，结合自己的经历做一个总结。</p>
<!-- more -->
<p>在每次分享之前都需要先反思以下几点：</p>
<h2 id="为什么要分享">为什么要分享</h2>
<p>做一次分享最重要的前提是知道为什么要做这次分享，其他伙伴能从这次分享中学习到什么呢？</p>
<blockquote>
<p>分享的本意就是总结并传播知识，分享的核心是利他。</p>
</blockquote>
<p>切忌为了展示自己的优秀而分享。</p>
<h2 id="什么是好的内容">什么是好的内容</h2>
<blockquote>
<p>高度总结的知识<br>
可以借鉴的经验：建设经验、推导过程……<br>
晦涩难懂的技术：深入浅出</p>
</blockquote>
<p>听众都比较熟识或者上网一查就能马上查到的内容就不要专门拿出来分享了，自己讲起来也没有底气，听众也没有兴趣听下去。</p>
<p>对于技术分享，如果把知识分为<code>基础</code>、 <code>进阶</code> 和 <code>精深</code> 三个阶段的话，分享的主题最好属于 <code>进阶</code> 和 <code>精深</code> 这两个阶段。</p>
<h2 id="如何去组织内容">如何去组织内容</h2>
<ol>
<li>结构性</li>
</ol>
<p>内容的讲解形式最好是总分总，即 <code>结论 -&gt; 论证讲解 -&gt; 总结</code> 三步走。</p>
<p>首先讲解结论，让听众先了解自己要讲什么内容。最后总结，帮助归纳总结， 加深听众对于内容的记忆深度。</p>
<ol start="2">
<li>故事性</li>
</ol>
<p>能把内容像讲故事一样讲出来当然更好，讲故事这方面不行的话就算了。</p>
<h2 id="如何去展示内容">如何去展示内容</h2>
<blockquote>
<p>少字多图！切忌念稿子！</p>
</blockquote>
<h2 id="如何去表达内容">如何去表达内容</h2>
<blockquote>
<p>吸引人的开场<br>
与观众有互动<br>
有停顿有节奏</p>
</blockquote>
<h2 id="必要条件">必要条件</h2>
<blockquote>
<p>保证质量！</p>
</blockquote>
<h2 id="参考">参考</h2>
<ol>
<li><a href="https://mp.weixin.qq.com/s/ZcHkIs00kVeyZ2-7u3cg5A">如何做一场高质量的分享</a>.</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何拦截Elementui RadioGroup的数据变更]]></title>
        <id>https://awhitemouse.github.io/post/ru-he-lan-jie-elementui-raio-group-de-shu-ju-bian-geng/</id>
        <link href="https://awhitemouse.github.io/post/ru-he-lan-jie-elementui-raio-group-de-shu-ju-bian-geng/">
        </link>
        <updated>2021-03-30T02:00:12.000Z</updated>
        <summary type="html"><![CDATA[<p>最近在做的一个业务场景需要劫持掉 <code>RadioGroup</code> 的内部的数据自动更新行为，然后根据外部的条件动态判断能否更新数据。</p>
]]></summary>
        <content type="html"><![CDATA[<p>最近在做的一个业务场景需要劫持掉 <code>RadioGroup</code> 的内部的数据自动更新行为，然后根据外部的条件动态判断能否更新数据。</p>
<!-- more -->
<h2 id="问题简述">问题简述</h2>
<p>界面如下图。最上方的Tabs标签页是一级分类（Tabs）；中间的按钮组（即RadioGroup）是二级分类；下方是数据展示面板，用于展示当前分类下的数据。</p>
<figure data-type="image" tabindex="1"><img src="https://awhitemouse.github.io//post-images/1617161503433.png" alt="" loading="lazy"></figure>
<p>如果数据展示面板被手动操作导致数据发生更改后，此时去切换上方的一级分类或者二级分类都需要弹出二次确认弹窗如下：</p>
<figure data-type="image" tabindex="2"><img src="https://awhitemouse.github.io//post-images/1617161868698.png" alt="" loading="lazy"></figure>
<h2 id="解决方案">解决方案</h2>
<p>我们的使用的组件库是<a href="https://element.eleme.cn/#/zh-CN/component/installation">element-ui 2</a>。</p>
<p>下面将针对不同的组件提出不同的数据劫持的方案。</p>
<h3 id="一级分类tabs">一级分类：Tabs</h3>
<p>Tabs组件提供了 <code>before-leave</code> 钩子，可以使用这个钩子完成对数据变更的劫持。</p>
<figure data-type="image" tabindex="3"><img src="https://awhitemouse.github.io//post-images/1617162183098.png" alt="" loading="lazy"></figure>
<p>使用示例如下：<br>
<img src="https://awhitemouse.github.io//post-images/1617162565503.png" alt="" loading="lazy"><br>
<img src="https://awhitemouse.github.io//post-images/1617162382412.png" alt="" loading="lazy"></p>
<h3 id="二级分类radiogroup">二级分类：RadioGroup</h3>
<p>相较于Tabs，RadioGroup的处理方案要复杂一些，因为这个组件并没有提供类似于 <code>before-leave</code> 的钩子，所以需要自行实现这一过程。</p>
<p>最初的想法是利用官方提供的 <code>value</code> 属性以及<code>chang</code>回调来完成这一过程。因为如果用 <code>v-model</code> 的话，Vue内部就会代理所有的数据处理，就不能完成自定义的数据劫持了。</p>
<figure data-type="image" tabindex="4"><img src="https://awhitemouse.github.io//post-images/1617163290456.png" alt="" loading="lazy"></figure>
<p>关键代码如下：</p>
<pre><code class="language-html">&lt;template&gt;
    &lt;el-tabs v-model=&quot;activeLevelGroup&quot; :before-leave=&quot;beforeLeave&quot; :class=&quot;$style['tabs']&quot;&gt;
        &lt;el-tab-pane
            v-for=&quot;key in bigCatLevelManage&quot;
            :key=&quot;key&quot;
            :label=&quot;BigCatLevelGroupName[key]&quot;
            :name=&quot;`${key}`&quot;
        &gt;
            &lt;!-- FIXME: value + change --&gt;
            &lt;el-radio-group :value=&quot;activeLevel&quot; size=&quot;small&quot; @change=&quot;onRadioChange&quot;&gt;
                &lt;el-radio-button
                    v-for=&quot;level in BigCatLevelManage[key]&quot;
                    :key=&quot;level&quot;
                    :label=&quot;level&quot;
                    :data-level=&quot;level&quot;
                &gt;
                    {{BigCatBookLevelName[level]}}
                &lt;/el-radio-button&gt;
            &lt;/el-radio-group&gt;
        &lt;/el-tab-pane&gt;
    &lt;/el-tabs&gt;
&lt;/template&gt;

&lt;script lang=&quot;ts&quot;&gt;
import {Vue, Prop, Component, Watch} from 'vue-property-decorator';

@Component
export default class LevelTab extends Vue {
    activeLevel = 0;

    onRadioChange(value) {
        // 这里拦截数据变更
        if (this.allowChange) {
            this.activeLevel = value;
        }
        else {
            // ……
        }
    }
}
&lt;/script&gt;
</code></pre>
<p>当我兴高采烈地去运行代码的时候发现实际效果与预想的效果差的十万八千里。</p>
<p>无论我点选哪个选项，该选项都会被点亮，并且再次点击也无法取消选中……😰</p>
<figure data-type="image" tabindex="5"><img src="https://awhitemouse.github.io//post-images/1617172179228.png" alt="" loading="lazy"></figure>
<p>到这里，继续靠推测去研究方案效率就很低了。不如干脆去看看element-ui 源码，看看<a href="https://github.com/ElemeFE/element/blob/dev/packages/radio/src/radio-group.vue">RadioGroup</a>和<a href="https://github.com/ElemeFE/element/blob/dev/packages/radio/src/radio-button.vue">RadioButton</a>的数据是怎么传递和更新的.</p>
<h2 id="radiogroup-与-radiobutton">RadioGroup 与 RadioButton</h2>
<p>先看了 RadioGroup 的源码，只在 <code>created</code> 钩子里看见了数据处理相关的代码。它监听了 <code>handleChange</code> 事件，并在监听到该事件后向上层发送 <code>change</code> 回调。</p>
<pre><code class="language-js">created() {
    this.$on('handleChange', value =&gt; {
        this.$emit('change', value);
    });
},
</code></pre>
<p>RadioGroup 没有更多关于数据处理的代码了，那么玄机就应该在 RadioButton 的源码里了，这里先贴一下 RadioButton 代码里有关数据处理的部分。</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;label
    class=&quot;el-radio-button&quot;
    :class=&quot;[
      size ? 'el-radio-button--' + size : '',
      { 'is-active': value === label },
      { 'is-disabled': isDisabled },
      { 'is-focus': focus }
    ]&quot;
    role=&quot;radio&quot;
    :aria-checked=&quot;value === label&quot;
    :aria-disabled=&quot;isDisabled&quot;
    :tabindex=&quot;tabIndex&quot;
    @keydown.space.stop.prevent=&quot;value = isDisabled ? value : label&quot;
  &gt;
    &lt;input
      class=&quot;el-radio-button__orig-radio&quot;
      :value=&quot;label&quot;
      type=&quot;radio&quot;
      v-model=&quot;value&quot;
      :name=&quot;name&quot;
      @change=&quot;handleChange&quot;
      :disabled=&quot;isDisabled&quot;
      tabindex=&quot;-1&quot;
      @focus=&quot;focus = true&quot;
      @blur=&quot;focus = false&quot;
    &gt;
    &lt;span
      class=&quot;el-radio-button__inner&quot;
      :style=&quot;value === label ? activeStyle : null&quot;
      @keydown.stop&gt;
      &lt;slot&gt;&lt;/slot&gt;
      &lt;template v-if=&quot;!$slots.default&quot;&gt;{{label}}&lt;/template&gt;
    &lt;/span&gt;
  &lt;/label&gt;
&lt;/template&gt;
&lt;script&gt;
  import Emitter from 'element-ui/src/mixins/emitter';

  export default {
    name: 'ElRadioButton',

    mixins: [Emitter],
    
    computed: {
      // **注意这里**
      value: {
        get() {
          return this._radioGroup.value;
        },
        set(value) {
          this._radioGroup.$emit('input', value);
        }
      },
      _radioGroup() {
        let parent = this.$parent;
        while (parent) {
          if (parent.$options.componentName !== 'ElRadioGroup') {
            parent = parent.$parent;
          } else {
            return parent;
          }
        }
        return false;
      },
    },

    methods: {
      handleChange() {
        this.$nextTick(() =&gt; {
          this.dispatch('ElRadioGroup', 'handleChange', this.value);
        });
      }
    }
  };
&lt;/script&gt;
</code></pre>
<p>从源码里可以看到，内部是使用 <code>&lt;input type=&quot;radio&quot; /&gt;</code> 实现的单选按钮。</p>
<p>当我们的使用了 <code>value</code> 来传递数据时，可以监听 <code>input</code> 回调来劫持数据的更改。</p>
<p>然后当我使用 <code>value</code> + <code>input</code> 的组合时，展示效果依然跟上面一样，所有的选项都会被点亮。我用Vue devtools查看数据的时候发现，数据传递确实中断了。而我所看到的<strong>点亮</strong>的效果，居然是 <code>input:checked</code> 样式造成的，而不是数据。</p>
<p>那么想要用 <code>value</code> 就必须要消除 <code>input</code> 的 <code>checked</code> 状态对样式的影响。所以当前最佳的办法就是自定义 <code>click</code> 方法，然后使用 <code>.prevent</code> 修饰符来屏蔽掉内部的点击事件。</p>
<h2 id="劫持radiogroup终极方案">“劫持”RadioGroup终极方案</h2>
<pre><code class="language-html">&lt;template&gt;
    &lt;el-tabs v-model=&quot;activeLevelGroup&quot; :before-leave=&quot;beforeLeave&quot; :class=&quot;$style['tabs']&quot;&gt;
        &lt;el-tab-pane
            v-for=&quot;key in bigCatLevelManage&quot;
            :key=&quot;key&quot;
            :label=&quot;BigCatLevelGroupName[key]&quot;
            :name=&quot;`${key}`&quot;
        &gt;
            &lt;el-radio-group :value=&quot;activeLevel&quot; size=&quot;small&quot;&gt;
                &lt;!-- NOTE：这里拦截了radio-button的向上冒泡。主要为了实现数据切换前进行一系列的判断 --&gt;
                &lt;el-radio-button
                    v-for=&quot;level in BigCatLevelManage[key]&quot;
                    :key=&quot;level&quot;
                    :label=&quot;level&quot;
                    :data-level=&quot;level&quot;
                    @click.native.prevent=&quot;handeClickRadio(level)&quot;
                &gt;
                    {{BigCatBookLevelName[level]}}
                &lt;/el-radio-button&gt;
            &lt;/el-radio-group&gt;
        &lt;/el-tab-pane&gt;
    &lt;/el-tabs&gt;
&lt;/template&gt;

&lt;script lang=&quot;ts&quot;&gt;
import {Vue, Prop, Component, Watch} from 'vue-property-decorator';

@Component
export default class LevelTab extends Vue {

    activeLevel =0;

    // 拦截radio-button向上冒泡，用于判断当前是否允许切换选项
    handeClickRadio(level: BigCatBookLevel) {
        // 如果当前点击的radio已经是选中状态，则不作处理
        if (level === this.activeLevel) {
            return;
        }
        this.beforeLeave().then(() =&gt; {
            this.activeLevel = level;
        });
    }
}
&lt;/script&gt;
</code></pre>
<h2 id="我是尾巴">我是尾巴</h2>
<p>至此，问题总算解决了，这也感谢其他小伙伴的帮助。</p>
<p>遇到这种问题的时候，还是要多看源码是怎么设计的，从里面寻找突破口。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GitHub Action: The process '/usr/bin/git' failed with exit code 128]]></title>
        <id>https://awhitemouse.github.io/post/github-action-gou-jian-shi-bai-chu-li/</id>
        <link href="https://awhitemouse.github.io/post/github-action-gou-jian-shi-bai-chu-li/">
        </link>
        <updated>2021-03-24T01:55:07.000Z</updated>
        <content type="html"><![CDATA[<p>最近发现了<a href="https://vuepress-theme-hope.github.io/zh">vuepress-theme-hope</a>这个强大的静态博客生成工具，它使用了<code>GitHub Action</code>来构建生成静态网页，但是在我发布代码之后，构建了好几次都没有成功。</p>
<h2 id="问题">问题</h2>
<p>错误日志：</p>
<blockquote>
<p>The process '/usr/bin/git' failed with exit code 128.</p>
</blockquote>
<p>截图：</p>
<figure data-type="image" tabindex="1"><img src="https://awhitemouse.github.io//post-images/1616550964478.png" alt="" loading="lazy"></figure>
<p>构建脚本：</p>
<pre><code class="language-yml">name: Deploy GitHub Pages

on:
  push:
    branches:
      - master

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v2
        with:
          persist-credentials: false

      - uses: actions/cache@v2.1.4
        id: node-modules
        with:
          path: node_modules/
          key: ${{ runner.os }}-node-modules-${{ hashFiles('yarn.lock') }}
          restore-keys: |
            ${{ runner.os }}-node-modules-

      - name: Install Deps
        if: steps.node-modules.outputs.cache-hit != 'true'
        run: yarn install --frozen-lockfile

      - name: Build Template
        run: yarn run build

      - name: Deploy
        uses: JamesIves/github-pages-deploy-action@releases/v3
        with:
          ACCESS_TOKEN: ${{ secrets.ACCESS_TOKEN }}
          BRANCH: gh-pages
          FOLDER: dist
</code></pre>
<h2 id="处理">处理</h2>
<p>经过多次的尝试，最后找到的原因是没有配置 <code>GITHUB_TOKEN</code> 属性。</p>
<p>配置以后的代码是这样的</p>
<pre><code class="language-yml">name: Deploy GitHub Pages

on:
  push:
    branches:
      - master

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v2
        with:
          persist-credentials: false

      - uses: actions/cache@v2.1.4
        id: node-modules
        with:
          path: node_modules/
          key: ${{ runner.os }}-node-modules-${{ hashFiles('yarn.lock') }}
          restore-keys: |
            ${{ runner.os }}-node-modules-

      - name: Install Deps
        if: steps.node-modules.outputs.cache-hit != 'true'
        run: yarn install --frozen-lockfile

      - name: Build Template
        run: yarn run build

      - name: Deploy
        uses: JamesIves/github-pages-deploy-action@releases/v3
        with:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}   /* 注意：这行是新加的 */
          ACCESS_TOKEN: ${{ secrets.ACCESS_TOKEN }}
          BRANCH: gh-pages
          FOLDER: dist
</code></pre>
<p>大功告成。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[为什么要在function之前加上"!"]]></title>
        <id>https://awhitemouse.github.io/post/wei-shi-me-yao-zai-function-zhi-qian-jia-shang/</id>
        <link href="https://awhitemouse.github.io/post/wei-shi-me-yao-zai-function-zhi-qian-jia-shang/">
        </link>
        <updated>2021-03-19T09:51:28.000Z</updated>
        <summary type="html"><![CDATA[<p>在某些第三方包中，会见到以 <code>!</code> 开头的代码，那么为什么要这么做呢？</p>
]]></summary>
        <content type="html"><![CDATA[<p>在某些第三方包中，会见到以 <code>!</code> 开头的代码，那么为什么要这么做呢？</p>
<!-- more -->
<p>这种代码的框架是这样的：</p>
<pre><code class="language-js">!function() {

}();
</code></pre>
<p>以这样的形式展现，可能不容易看出来是怎么回事，这么写的用意是什么？</p>
<p>接下来再看另外一个常见的第三方包的导出代码形式：</p>
<pre><code class="language-js">(function() {

})()
</code></pre>
<p>其实， <code>!</code> 的作用跟 <code>()</code> 的作用相同，都是将后面的部分解析成函数表达式去执行。</p>
<p>同样作用的还有 <code>~</code>、<code>+</code>、<code>-</code> 等等。</p>
<h2 id="参考">参考</h2>
<ol>
<li><a href="https://swordair.com/function-and-exclamation-mark/">function与感叹号</a>.</li>
<li><a href="https://segmentfault.com/q/1010000000117476">javascript里function之前加上感叹号 ' ! ' 会怎么样？</a>.</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JS实现字符串的批量替换]]></title>
        <id>https://awhitemouse.github.io/post/js-shi-xian-zi-fu-chuan-de-pi-liang-ti-huan/</id>
        <link href="https://awhitemouse.github.io/post/js-shi-xian-zi-fu-chuan-de-pi-liang-ti-huan/">
        </link>
        <updated>2021-03-15T07:26:33.000Z</updated>
        <content type="html"><![CDATA[<p>有一个对象数据结构如下：</p>
<pre><code class="language-js">obj = {
    content: '准备将#网址导航项目#由静态网页项目改装为#React项目#，减少重复代码。',
    links: ['https://github.com/WebStackPage/WebStackPage.github.io', 'http: //www.baidu.com'],
}
</code></pre>
<p>现在需要使用原生JS完成字符串替换工作：找到<code>content</code>中使用<code>#</code>号标识符包裹的字符串，将其改成使用<code>a标签</code>包裹，<code>a标签</code>的<code>href</code>依次使用<code>links</code>中的数据项。</p>
<p>替换后的结果应如下：</p>
<pre><code class="language-html">准备将&lt;a href=&quot;https://github.com/WebStackPage/WebStackPage.github.io&quot;&gt;网址导航项目&lt;/a&gt;由静态网页项目改装为&lt;a href=&quot;http://baidu.com&quot;&gt;React项目&lt;/a&gt;，减少重复代码。
</code></pre>
<h2 id="实现">实现</h2>
<pre><code class="language-js">// 先将字符串拆解
const textArr = a.content.split('#');
// 最后的结果
let result = '';
// 标志位：用于判断当前应该添加开标签还是闭标签
let flag = 0;
// 如果第一个字符就是#号，那么从第一个字符开始添加开标签
if (a.content[0] === '#') {
    result += '&lt;a href=&quot;' + a.links[0] + '&quot;&gt;';
    flag = ~flag;
}
textArr.forEach((text, index) =&gt; {
    if (flag) {
        // 如果已经添加过开标签，则现在应该添加标签
        result += text + '&lt;/a&gt;';
    }
    else if (index !== textArr.length - 1) {
        // 如果前一个添加的标签是闭标签，并且当前不是数组的最后一个数据，则添加开标签
        result += text + '&lt;a href=&quot;' + a.links[index / 2] + '&quot;&gt;';
    }
    else {
        // 最后一个数据项，前一个添加的是闭标签，则直接连接文本
        result += text;
    }
    // 每次连接文本都更改一下标志位
    flag = ~flag;
})
console.log(result);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git 提交部分代码]]></title>
        <id>https://awhitemouse.github.io/post/git-ti-jiao-bu-fen-dai-ma/</id>
        <link href="https://awhitemouse.github.io/post/git-ti-jiao-bu-fen-dai-ma/">
        </link>
        <updated>2021-03-11T07:40:28.000Z</updated>
        <content type="html"><![CDATA[<p>如果我们开发过程中，需要先提交一部分代码，该怎么做呢？</p>
<h2 id="关键步骤">关键步骤</h2>
<pre><code class="language-shell">git add demo.html // 提交到暂存区
git stash -u -k  // 忽略其他修改，关键一步
git commit -m '修改演示文件' // 提交暂存区
git pull // 拉取合并
git push origin master // 推到远程仓库
git stash pop // 恢复之前忽略的文件（非常重要的一步）
</code></pre>
<h2 id="参考链接">参考链接</h2>
<ol>
<li><a href="https://blog.csdn.net/DongFuPanda/article/details/104246064">git 只提交部分文件到远程仓库</a>.</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Redux与Vuex的区别]]></title>
        <id>https://awhitemouse.github.io/post/redux-yu-vuex-de-qu-bie/</id>
        <link href="https://awhitemouse.github.io/post/redux-yu-vuex-de-qu-bie/">
        </link>
        <updated>2021-03-08T08:51:17.000Z</updated>
        <content type="html"><![CDATA[<h2 id="相同点">相同点</h2>
<ol>
<li>唯一的数据源</li>
<li>全局注入store</li>
</ol>
<h2 id="不同点">不同点</h2>
<ol>
<li>vuex直接修改原来的数据；redux根据原来的数据进行计算后返回新的数据</li>
<li>vuex定义了 state 、getter 、mutation 、 action四个对象；redux定义了state  、 reducer 、 action三个对象</li>
<li>vuex中mutation用于同步操作，action用于异步操作；redux中action既用于同步操作，也用于异步操作，用于异步操作时需要引入引入第三方包（redux-thunk\redux-saga）</li>
<li>vuex使用commit派发同步方法，dispatch派发异步方法；redux都用dispatch派发</li>
<li>vuex使用mutation修改状态；redux使用reducer修改状态</li>
</ol>
<h2 id="参考链接">参考链接</h2>
<ol>
<li><a href="https://lq782655835.github.io/blogs/react/diff-vuex-redux.html">Vuex与Redux比较</a>.</li>
<li><a href="https://juejin.cn/post/6844903929063424013">Redux 和 Vuex 的对比</a>.</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[腾讯移动端开发规范]]></title>
        <id>https://awhitemouse.github.io/post/teng-xun-yi-dong-duan-kai-fa-gui-fan/</id>
        <link href="https://awhitemouse.github.io/post/teng-xun-yi-dong-duan-kai-fa-gui-fan/">
        </link>
        <updated>2021-02-20T07:33:47.000Z</updated>
        <content type="html"><![CDATA[<p>要考虑Android低端机与2G网络场景下性能 <code>注意！</code></p>
<h3 id="发布前必要检查项">发布前必要检查项</h3>
<ul>
<li>所有图片必须有进行过压缩</li>
<li>考虑适度的有损压缩，如转化为80%质量的jpg图片</li>
<li>考虑把大图切成多张小图，常见在banner图过大的场景</li>
</ul>
<h3 id="加载性能优化-达到打开足够快">加载性能优化, 达到打开足够快</h3>
<ul>
<li>数据离线化，考虑将数据缓存在 localStorage</li>
<li>初始请求资源数 &lt; 4 注意！</li>
<li>图片使用CSS Sprites 或 DataURI</li>
<li>外链 CSS 中避免 @import 引入</li>
<li>考虑内嵌小型的静态资源内容</li>
<li>初始请求资源gzip后总体积 &lt; 50kb</li>
<li>静态资源(HTML/CSS/JS/Image)是否优化压缩？</li>
<li>避免打包大型类库</li>
<li>确保接入层已开启Gzip压缩（考虑提升Gzip级别，使用CPU开销换取加载时间）<code>注意！</code></li>
<li>尽量使用CSS3代替图片</li>
<li>初始首屏之外的静态资源（JS/CSS）延迟加载 <code>注意！</code></li>
<li>初始首屏之外的图片资源按需加载（判断可视区域） <code>注意！</code></li>
<li>单页面应用(SPA)考虑延迟加载非首屏业务模块</li>
<li>开启Keep-Alive链路复用</li>
</ul>
<h3 id="运行性能优化-达到操作足够流畅">运行性能优化, 达到操作足够流畅</h3>
<ul>
<li>避免 iOS 300+ms 点击延时问题 <code>注意！</code></li>
<li>缓存 DOM 选择与计算</li>
<li>避免触发页面重绘的操作</li>
<li>Debounce连续触发的事件(scroll / resize / touchmove等)，避免高频繁触发执行 <code>注意！</code></li>
<li>尽可能使用事件代理，避免批量绑定事件</li>
<li>使用CSS3动画代替JS动画</li>
<li>避免在低端机上使用大量CSS3渐变阴影效果，可考虑降级效果来提升流畅度</li>
<li>HTML结构层级保持足够简单</li>
<li>尽能少的使用CSS高级选择器与通配选择器</li>
<li>Keep it simple</li>
</ul>
<h2 id="参考链接">参考链接</h2>
<ol>
<li><a href="http://alloyteam.github.io/Spirit/modules/Standard/index.html">移动开发规范概述</a>.</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Chrome浏览器截长屏]]></title>
        <id>https://awhitemouse.github.io/post/chrome-liu-lan-qi-jie-chang-ping/</id>
        <link href="https://awhitemouse.github.io/post/chrome-liu-lan-qi-jie-chang-ping/">
        </link>
        <updated>2021-02-15T03:26:27.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://awhitemouse.github.io//post-images/1613359611986.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
</feed>