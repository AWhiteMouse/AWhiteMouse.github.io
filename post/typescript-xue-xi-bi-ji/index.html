<html>
<head>
    <meta charset="utf-8" />
<meta name="description" content="一位前端开发者的学习笔记与踩坑指南" />
<meta name="keywords" content="web,html,css,js,es6,nodejs,react,antd,webpack,redux,jenkins,踩坑,学习笔记,微信小程序,微信公众号,适配,git,github,gitee" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Typescript学习笔记 | 白山</title>
<link rel="shortcut icon" href="https://awhitemouse.github.io//favicon.ico?v=1618475543194">
<!-- <link href="https://cdn.bootcss.com/font-awesome/5.11.2/css/all.css" rel="stylesheet"> -->
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.css">
<link rel="stylesheet" href="https://awhitemouse.github.io//styles/main.css">
<link rel="stylesheet" href="https://awhitemouse.github.io//media/live2d/css/live2d.css">
<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css"
    integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">

<script src="https://cdn.bootcss.com/highlight.js/9.15.10/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dockerfile.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dart.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/go.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>
<script src="https://code.jquery.com/jquery-3.4.1.slim.min.js"
    integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n" crossorigin="anonymous">
</script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"
    integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous">
</script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js"
    integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous">
</script>

<!-- DEMO JS -->
<!-- <script src="/media/scripts/index.js"></script> -->

<!-- 百度统计 -->
<script>
    var _hmt = _hmt || [];
    (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?d67319f5aed3ec93a230772fe9c25ab5";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>


    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
</head>
<body>
<div class="main gt-bg-theme-color-first">
    <nav class="navbar navbar-expand-lg">
    <div class="navbar-brand">
        <img class="user-avatar" src="/images/avatar.png" alt="头像">
        <div class="site-name gt-c-content-color-first">
            白山
        </div>
    </div>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <i class="fa fa-bars gt-c-content-color-first" style="font-size: 18px"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <div class="navbar-nav mr-auto" style="text-align: center">
            
                <div class="nav-item">
                    
                        <a href="/" class="menu gt-a-link">
                            首页
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/archives" class="menu gt-a-link">
                            归档
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/tags" class="menu gt-a-link">
                            标签
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/navigation" class="menu gt-a-link">
                            导航
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/post/about" class="menu gt-a-link">
                            关于
                        </a>
                    
                </div>
            
        </div>
    </div>
</nav>
    <div class="post-container">
        <div class="post-detail gt-bg-theme-color-second">
            <article class="gt-post-content">
                <h2 class="post-title">
                    Typescript学习笔记
                </h2>
                <div class="post-info">
                    <time class="post-time gt-c-content-color-first">
                        · 2020-05-10 10:07:10 ·
                    </time>
                    
                        <a href="https://awhitemouse.github.io/tag/lQxKPGr7h/" class="post-tags">
                            # Typescript
                        </a>
                    
                </div>
                <div class="post-content">
                    <h1 id="安装">安装</h1>
<pre><code>npm install typescript
</code></pre>
<h1 id="生成配置文件tsconfigjson">生成配置文件：tsconfig.json</h1>
<pre><code>npx tsc --init
</code></pre>
<h1 id="ts中的数据类型">ts中的数据类型</h1>
<ul>
<li>boolean：布尔</li>
<li>number：数字</li>
<li>string：字符串</li>
<li>array：数组</li>
<li>tuple：元组</li>
<li>enum：枚举</li>
<li>any：任意类型</li>
<li>null 和 undefined</li>
<li>void</li>
<li>never</li>
</ul>
<h2 id="数据类型定义方法">数据类型定义方法</h2>
<h3 id="定义原始类型">定义原始类型</h3>
<p>boolean、number、string</p>
<pre><code class="language-ts">const flag: boolean = false;
</code></pre>
<h3 id="定义数组类型">定义数组类型</h3>
<p>第一种方式：</p>
<pre><code class="language-ts">const sArr: string[] = ['1', 'dhdh'];
let nArr: number[] = [1, 2, 10];

// 定义任意类型的数组
let aArr: any[] = ['dd', 123];
</code></pre>
<p>第二种方式（使用泛型）：</p>
<pre><code class="language-ts">let arr: Array&lt;number&gt; = [1, 45, 67];
</code></pre>
<pre><code class="language-ts">let arr: Array&lt;any&gt; = ['dd', 123];
</code></pre>
<h3 id="定义元组类型">定义元组类型</h3>
<p>属于数组的一种，定义数组中每一项的类型</p>
<pre><code class="language-ts">let arr: [string, number, boolean] = ['哈哈', 23, false];
</code></pre>
<h3 id="定义枚举类型">定义枚举类型</h3>
<p>如果给枚举类型赋值了，使用的是赋值的数据</p>
<pre><code class="language-ts">enum Flag {
    success = 1,
    error = -1
}

let flag: Flag = Flag.success;  // 1
</code></pre>
<p>如果没有给枚举类型赋值，使用的是索引值（index）</p>
<pre><code class="language-ts">enum Color {
    red, blue, orange
}

let a: Color = Color.red;  // 0
let b: Color = Color.blue;  // 1
let c: Color = Color.orange;  // 2
</code></pre>
<p>如果给其中某写枚举值赋值了，其他一些枚举值没有赋值，后面的枚举值会在前面已经定义的枚举值基础上递增</p>
<pre><code class="language-ts">enum Color {
    red,
    blue = 5,
    orange
}

let a: Color = Color.red;  // 0
let b: Color = Color.blue;  // 5
let c: Color = Color.orange;  // 6
</code></pre>
<h3 id="定义任意类型">定义任意类型</h3>
<pre><code class="language-ts">let num: any = 123;
num = '456';
num = false;
</code></pre>
<h3 id="定义-null-和-undefined-类型">定义 null 和 undefined 类型</h3>
<p>其他（never类型）数据类型的子类型</p>
<pre><code class="language-ts">var num: undefined;
console.log(num);
</code></pre>
<pre><code class="language-ts">var num: number | undefined;
num = 123;
console.log(num);
</code></pre>
<h3 id="定义-void-类型">定义 void 类型</h3>
<p>一般用于定义没有返回值的方法</p>
<pre><code class="language-ts">function run(): void {
    console.log('我没有return哦');
}
</code></pre>
<h3 id="定义其他类型never">定义其他类型（never）</h3>
<p>是其他类型（包括 null 和 undefined）的子类型，表示从不会出现的值。</p>
<p>这个类型基本不会用到。</p>
<pre><code class="language-ts">var a: undefined;
a = undefined;
</code></pre>
<pre><code class="language-ts">var a: never;

a = (() =&gt; {
    throw new Error('报错');
})();
</code></pre>
<h2 id="函数的定义">函数的定义</h2>
<p>定义返回值</p>
<pre><code class="language-ts">function run(): string {
    return 'haha';
}

const fun = function(): number {
    return 123;
}
</code></pre>
<p>定义传参</p>
<pre><code class="language-ts">function run(name: string, age: number): string {
    return `${name}--${age}`;
}

const fun = function(name: string, age: number): string {
    return `${name}--${age}`;
};

// 加上 ? 表示可选参数，可传可不传
// 【注意】可选参数必须放在参数的最后面！！！
const fun2 = function(name: string, age?: number): string {
    if (age) {
        return `${name}--${age}`;
    } else {
        return `${name}--保密`;
    }
};

// 默认参数
const fun3 = function(name: string, age: number = 20): string {
    if (age) {
        return `${name}--${age}`;
    } else {
        return `${name}--保密`;
    }
};

// 剩余参数
const fun4 = function(a, b, ...rest:number[]): void {
    let sum = 0;
    for (let i = 0; i &lt; rest.length; i++) {
        sum += rest[i];
    }
    console.log(a, b, sum);
};
fun4(1, 2, 3, 4);  // 1 2 7

// 函数重载
function getInfo(age: number): string;
function getInfo(name: string): string;
function getInfo(str: any):any {
    if (typeof str === 'number') {
        return `我今年${str}岁`;
    } 
    return `我叫${str}`;
}

getInfo(12);  // 我今年12岁
getInfo('明明');  // 我叫明明
// 报错，因为没有定义 boolean 类型
// getInfo(false); 
</code></pre>
<h1 id="ts中的类">ts中的类</h1>
<h2 id="类的定义">类的定义</h2>
<pre><code class="language-ts">class Person {
    name: string;  // 属性 前面省略了public关键词

    constructor(name: tring) {
        this.name = name;
    }

    getName(): void {
        console.log(this.name);
    }

    setName(name: string): void {
        this.name = name;
    }
}

const p = new Person('张三');
p.getName();  // 张三
p.setName('李四');
p.getName();  // 李四
</code></pre>
<h2 id="继承extends-super">继承：extends + super</h2>
<pre><code class="language-ts">class Person {
    name: string;  // 属性 前面省略了public关键词

    constructor(name: tring) {
        this.name = name;
    }

    run(): string {
        return this.name;
    }
}

class Web extends Person {
    constructor(name: string) {
        super(name);
    }
}

const w = new Web('张三');
w.run();  // 张三
</code></pre>
<h2 id="类里面的修饰符">类里面的修饰符</h2>
<p>public、protected、private</p>
<p>属性的修饰符默认是公有（public）。</p>
<h1 id="ts中的接口">ts中的接口</h1>
<p>使用 <code>interface</code> 关键字定义接口。</p>
<h2 id="属性接口">属性接口</h2>
<pre><code class="language-ts">interface FullName {
    firstName: string;
    secondName: string;
}

function printName(name: FullName) {
    console.log(name.firstName + '--' + name.secondName);
}

// 这种写法不允许对象中传入多余的属性
printName({
    firstName: '张',
    secondName: '三',
})

// 待确认？：可以传入其他的属性
const obj = {
    age: 18,
    firstName: '张',
    secondName: '三',
};
printName(obj);
</code></pre>
<h3 id="可选属性">可选属性</h3>
<pre><code class="language-ts">interface FullName {
    firstName: string;
    secondName: string;
    // 可选属性
    age?: number;
}

function getName(name: FullName) {
    console.log(name.firstName + name.secondName + name.age);
}

getName({
    firstName: '张',
    secondName: '三',
})

getName({
    firstName: '张',
    secondName: '三',
    age: 18,
})
</code></pre>
<h2 id="函数类型接口">函数类型接口</h2>
<pre><code class="language-ts">interface encrypt {
    (key: string, value: string): string;
}

const md5: encrypt = function(key: string, value: string): string {
    return key + value;
};
console.log(md5('name', 'zhangsan'));

const test: encrypt = function(key: string, value: string): string {
    return key + '--' + value;
};
console.log(test('name', 'zhangsan'));
</code></pre>
<h2 id="可索引接口数组-对象的约束不常用">可索引接口：数组、对象的约束（不常用）</h2>
<pre><code class="language-ts">// 数组约束
interface UserArr {
    // 规定数组每一项数据都是 string 类型
    [index: number]: string;
}

const arr: UserArr = ['aaa', 'bbb'];
// const arr: UserArr = [123, 'bbb'];  // 错误写法

// 对象约束
interface UserObj {
    [index: string]: string;
}

const obj: UserObj ={
    name: '张三',
};
</code></pre>
<h2 id="类类型接口">类类型接口</h2>
<pre><code class="language-ts">interface Animal {
    name: string;
    eat(str: string): void;
}

class Dog implements Animal {
    name: string;

    constructor(name: string) {
        this.name = name;
    }

    // 虽然定义传了参数，但是不传参数也是可以的
    // 虽然可以不传参数，但是这个方法必须定义
    eat() {
        console.log(this.name + '吃粮食');
    }
}

const d = new Dog('旺财');
d.eat();
</code></pre>
<h2 id="接口扩展接口可以继承接口">接口扩展：接口可以继承接口</h2>
<pre><code class="language-ts">interface Animal {
    eat(): void;
}

interface Personal extends Animal {
    work(): void;
}

class Web implements Personal {
    public name: string;

    constructor(name: string) {
        this.name = name;
    }

    // 当类所继承的接口继承了其他接口的时候，这个类还必须实现其父级接口的方法
    eat() {
        console.log(this.name + '吃');
    }

    work() {
        console.log(this.name + '工作');
    }
}

const w = new Web('李四');
w.eat();
w.work();
</code></pre>
<h1 id="ts中的泛型">ts中的泛型</h1>
<p>作用是校验类型，却不固定类型。一般用于模板通用方法。</p>
<h2 id="泛型函数">泛型函数</h2>
<p>简单示例：</p>
<pre><code class="language-ts">function a&lt;T&gt;(value: T): T {
    return value;
}
</code></pre>
<h2 id="泛型类">泛型类</h2>
<pre><code class="language-ts">// 这里的 T 就是泛型，通过对最外面的 T 的类型的定义，决定了其内部的所有的 T 的类型的定义。
class Min&lt;T&gt; {
    public list: T[] = [];

    add(value: T): void {
        this.list.push(value);
    }

    min(): T {
        let minNum = this.list[0];
        for (let i = 0; i &lt; minNum.length; i++) {
            if (minNum &gt; this.list[i]) {
                minNum = this.list[i];
            }
        }
        return minNum;
    }
}

const m1 = new Min&lt;number&gt;();
m1.add(12);
m1.add(3);
m1.add(9);
console.log(m1.min());  // 3

const m2 = new Min&lt;string&gt;();
m2.add('j');
m2.add('v');
m2.add('a');
console.log(m2.min());  // a
</code></pre>
<h2 id="泛型接口">泛型接口</h2>
<p>第一种写法：</p>
<pre><code class="language-ts">interface ConfigFn {
    &lt;T&gt;(value: T): T;
}

const getData: ConfigFn = function&lt;T&gt;(value: T): T {
    return value;
}

getData&lt;string&gt;('张三');
</code></pre>
<p>第二种写法：</p>
<pre><code class="language-ts">interface ConfigFn&lt;T&gt; {
    (value: T): T;
}

function getData&lt;T&gt;(value: T): T {
    return value;
}

const myGetData: ConfigFn&lt;string&gt; = getData;

myGetData('20');
</code></pre>
<h1 id="装饰器">装饰器</h1>
<p>装饰器是一种特殊类型的声明，它能够被附加到类声明，方法，属性或者参数上，可以修改类的行为。</p>
<p>常见的装饰器有：类装饰器，属性装饰器，方法装饰器，参数装饰器。</p>
<h2 id="类装饰器">类装饰器</h2>
<h3 id="普通装饰器">普通装饰器</h3>
<pre><code class="language-ts">// 装饰器
function logClass(params: any) {
    console.log(params);  // 打印的就是被装饰的类
    params.prototype.apiUrl = '动态扩展的属性';
}

@logClass
class HttpClient {
    constructor() {

    }

    getData() {

    }
}

const http: any = new HttpClient();
console.log(http.apiUrl);
</code></pre>
<h3 id="装饰器工厂">装饰器工厂</h3>
<p>可以传入参数</p>
<pre><code class="language-ts">function logClass(params: string) {
    return  function(target: any) {
        console.log(target);  // HttpClient
        console.log(params);  // hello
    };
}

@logClass('hello')
class HttpClient {
    constructor() {

    }

    getData() {

    }
}
</code></pre>
<h2 id="属性装饰器">属性装饰器</h2>
<p>属性装饰器表达式会在运行时当做函数被调用，传入下列两个参数：</p>
<ol>
<li>对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。</li>
<li>成员的名字。</li>
</ol>
<pre><code class="language-ts">function logProperty(params: any) {
    return function(target: any, attr: any) {
        console.log(target);  // HttpClient
        console.log(attr);  // 'url'

        target[attr] = params;  // 修改URL
    }
}

class HttpClient {
    @logProperty('http://www.baidu.com')
    public url : anty | undefined;

    constructor() {}

    getData() {
        console.log(this.url);
    }
}

const http = new HttpClient();
http.getData();  // 'http://www.baidu.com'
</code></pre>
<h2 id="方法装饰器">方法装饰器</h2>
<p>它被应用到方法的属性描述符上，可以用来监视，修改或者替换方法定义。方法装饰器会在运行时传入下列三个参数：</p>
<ol>
<li>对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。</li>
<li>成员的名字。</li>
<li>成员的属性描述符。</li>
</ol>
<pre><code class="language-ts">function logMethod(params: any) {
    return function (target: any, methodName: any, desc: any) {
        console.log(target);
        console.log(methodName);
        console.log(desc);  // getData

        // 添加属性和方法
        target.apiUrl = 'xxx';
        target.run = function() {
            console.log('run');
        };

        // 修改装饰器的方法，把装饰器方法里面传入的所有参数改为 string 类型
        // 先将原始方法保留
        const oMethod = desc.value;
        // 修改方法
        desc.value = function (...args: any[]) {
            args = args.map(item =&gt; {
                return String(value);
            });

            // 对象冒充
            // 如果去掉这句话，原始方法就不会执行了，等同于替换了原始方法；加上这句话，会先执行这个被修改的方法，然后运行原始方法
            oMethod.apply(this, args);
        }
    };
}

class HttpClient{
    public url: any | undefined;

    constructor() {}

    @logMethod('http://www.baidu.com')
    getData() {
        consoe.log(this.url);
    }
}

const http: any = new HttpClient();
console.log(http.apiUrl);
http.run();
</code></pre>
<h2 id="参数装饰器">参数装饰器</h2>
<p>参数装饰器表达式会在运行时当做函数调用，可以使用参数装饰器为类的原型增加一些元素数据，传入下列3个参数：</p>
<ol>
<li>对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。</li>
<li>方法的名字。</li>
<li>参数在函数参数列表中的索引。</li>
</ol>
<pre><code class="language-ts">function logParams(params: any) {
    return function (target: any, methodName: any, paramsIndex: any) {
        console.log(params);  // haha
        console.log(target);  // HttpClient
        console.log(methodName);  // getData
        console.log(paramsIndex);  // 0

        targrt.apiUrl = params;
    };
}

class HttpClient {
    public url: any | undefined;

    constructor() {}

    getData(@logParams('haha') uuid: any) {
        console.log(uuid);  // 123456
    }
}

const http = new HttpClient();
http.getData(123456);
console.log(http.apiUrl);  // haha
</code></pre>
<h2 id="装饰器执行顺序">装饰器执行顺序</h2>
<p>属性 》方法 》方法参数 》类。</p>
<p>如果有多个同样的装饰器，在后面的装饰器会先执行。</p>
<h1 id="参考链接">参考链接</h1>
<p><a href="https://www.bilibili.com/video/BV1yt411e7xV">Typescript教程</a>.</p>

                </div>
            </article>
        </div>

        
            <div class="next-post">
                <div class="next gt-c-content-color-first">下一篇</div>
                <a href="https://awhitemouse.github.io/post/react-proptypes-ke-xuan-lei-xing/" class="post-title gt-a-link">
                    React PropTypes可选类型
                </a>
            </div>
        

        
            
                <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '1c7817279f236848ef3b',
    clientSecret: 'cc9a052a730aca58df4ac91361957979a7fb5396',
    repo: 'AWhiteMouse.github.io',
    owner: 'AWhiteMouse',
    admin: ['AWhiteMouse'],
    id: location.pathname,      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

            

            
        

        <div class="site-footer gt-c-content-color-first">
    <div class="slogan gt-c-content-color-first">温故而知新。</div>
    <div class="social-container">
        
        
        <a href="https://github.com/AWhiteMouse" target="_blank">
            <i class="fa fa-github gt-c-content-color-first"></i>
        </a>
        
        
        
        <a href="https://wpa.qq.com/msgrd?v=3&amp;uin=1586671591&amp;site=qq&amp;menu=yes" target="_blank">
            <i class="fa fa-qq gt-c-content-color-first"></i>
        </a>
        
        
        
        <a href="https://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=r9vOwc7NzsPa797egczAwg" target="_blank">
            <i class="fa fa-envelope gt-c-content-color-first"></i>
        </a>
        
        
        
        <a href="https://blog.csdn.net/i_dont_know_a" target="_blank">
            <i class="fa fa-rss gt-c-content-color-first"></i>
        </a>
        
        
        
        
        
        
        
        
        
        
        
        
    </div>
    Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a href="https://awhitemouse.github.io//atom.xml" target="_blank">RSS</a>
</div>

<div id="landlord" style="left:5px;bottom:0px;">
    <div class="message" style="opacity:0"></div>
    <canvas id="live2d" width="500" height="560" class="live2d"></canvas>
    <div class="live_talk_input_body">
        <div class="live_talk_input_name_body">
            <input name="name" type="text" class="live_talk_name white_input" id="AIuserName" autocomplete="off"
                placeholder="你的名字" />
        </div>
        <div class="live_talk_input_text_body">
            <input name="talk" type="text" class="live_talk_talk white_input" id="AIuserText" autocomplete="off"
                placeholder="要和我聊什么呀？" />
            <button type="button" class="live_talk_send_btn" id="talk_send">发送</button>
        </div>
    </div>
    <input name="live_talk" id="live_talk" value="1" type="hidden" />
    <div class="live_ico_box">
        <div class="live_ico_item type_info" id="showInfoBtn"></div>
        <div class="live_ico_item type_talk" id="showTalkBtn"></div>
        <div class="live_ico_item type_music" id="musicButton"></div>
        <div class="live_ico_item type_youdu" id="youduButton"></div>
        <div class="live_ico_item type_quit" id="hideButton"></div>
        <input name="live_statu_val" id="live_statu_val" value="0" type="hidden" />
        <audio src="" style="display:none;" id="live2d_bgm" data-bgm="0" preload="none"></audio>
        <input name="live2dBGM" value="http://music.163.com/song/media/outer/url?id=1313102578.mp3" type="hidden">
        <input id="duType" value="douqilai,l2d_caihong" type="hidden">
    </div>
</div>
<div id="open_live2d">召唤伊斯特瓦尔</div>

<script type="text/javascript" src="https://apps.bdimg.com/libs/jquery/1.7.1/jquery.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
    var message_Path = '/media/live2d/'; //资源目录，如果目录不对请更改
    var talkAPI = ""; //如果有类似图灵机器人的聊天接口请填写接口路径
</script>
<script type="text/javascript" src="/media/live2d/js/live2d.js"></script>
<script type="text/javascript" src="/media/live2d/js/message.js"></script>
<!-- <script src="//code.tidio.co/fkwn1bueaqmcolzjchxzh7xoz5ahzrtw.js" async></script> -->

    </div>
</div>
</body>
</html>
